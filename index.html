<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Missile Command</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- (Previous CSS remains the same) --- */
        body { display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 30px; min-height: 100vh; background-color: #000; margin: 0; font-family: 'Press Start 2P', cursive; color: #00ff00; overflow: hidden; }
        h1#mainTitle { color: #ff0000; font-size: 36px; margin-bottom: 20px; text-shadow: 2px 2px #ffff00; display: block; }
        #gameCanvas { background-color: #111; display: none; border: 2px solid #00ff00; box-shadow: 0 0 15px #00ff00; cursor: crosshair; max-width: 100%; height: auto; image-rendering: pixelated; position: relative; }
        #uiContainer { display: none; flex-wrap: wrap; justify-content: space-between; align-items: center; width: 800px; max-width: 95%; padding: 10px 0; font-size: 14px; }
        #bonusIndicator { color: #ffaa00; font-weight: bold; text-shadow: 1px 1px #000; display: none; margin: 0 15px; order: 5; }
        #controlsContainer { margin-top: 15px; display: none; flex-wrap: wrap; justify-content: center; gap: 15px; }
        #startMenuContainer { display: flex; flex-direction: column; align-items: center; }
        #difficultySelection { display: flex; flex-direction: column; align-items: center; gap: 15px; margin-top: 0; padding: 20px; border: 2px solid #ffff00; border-radius: 10px; background-color: rgba(30, 30, 0, 0.5); }
        #difficultySelection h3 { margin: 0 0 15px 0; color: #ffff00; font-size: 18px; text-align: center; }
        button { font-family: 'Press Start 2P', cursive; background-color: #333; color: #00ff00; border: 2px solid #00ff00; padding: 10px 20px; font-size: 16px; cursor: pointer; box-shadow: 0 0 10px #00ff00 inset; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; border-radius: 5px; white-space: nowrap; }
        .difficulty-button { border-color: #ffff00; color: #ffff00; box-shadow: 0 0 10px #ffff00 inset; min-width: 200px; text-align: center; }
        .difficulty-button:hover:not(:disabled), .difficulty-button:focus:not(:disabled) { box-shadow: 0 0 15px #ffff00 inset, 0 0 10px #ffff00; background-color: #444; }
        .difficulty-button.selected { background-color: #555500; box-shadow: 0 0 15px #ffff00 inset, 0 0 15px #ffff00; color: #fff; }
        #actualStartButton { margin-top: 25px; display: none; }
        button:hover:not(:disabled), button:focus:not(:disabled) { background-color: #444; outline: none; }
        button:not(.difficulty-button):hover:not(:disabled) { box-shadow: 0 0 15px #00ff00 inset, 0 0 10px #00ff00; }
        button:active:not(:disabled) { background-color: #222; }
        button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }
        #messageBox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); border: 3px solid #ff0000; padding: 30px; text-align: center; font-size: 24px; color: #ff0000; display: none; z-index: 10; box-shadow: 0 0 20px #ff0000; border-radius: 10px; width: 80%; max-width: 500px; }
        #messageBox h2 { margin: 0 0 15px 0; font-size: 32px; }
        #messageBox p { margin: 5px 0 15px 0; font-size: 16px; color: #ffff00; }
        #messageBox p.bonus-alert { color: #ffaa00; font-weight: bold; display: none; }
        .messageBoxButtons { margin-top: 20px; display: flex; justify-content: center; gap: 20px; }
        #goToStoreButton, #skipStoreButton { display: none; }
        #pauseOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: #ffff00; display: flex; align-items: center; justify-content: center; font-size: 48px; text-shadow: 3px 3px #ff0000; z-index: 15; display: none; pointer-events: none; }
        #storeModal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 600px; background-color: rgba(0, 20, 0, 0.9); border: 3px solid #00ff00; border-radius: 15px; box-shadow: 0 0 25px #00ff00; padding: 25px; z-index: 20; display: none; color: #00ff00; font-size: 14px; }
        #storeModal h2 { font-size: 28px; margin: 0 0 20px 0; text-align: center; color: #ffff00; }
        #storeScore { font-size: 18px; margin-bottom: 20px; text-align: center; color: #fff; }
        .storeItem { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background-color: rgba(0, 50, 0, 0.7); border-radius: 5px; border: 1px solid #008800; }
        .storeItemInfo { flex-grow: 1; margin-right: 15px; }
        .storeItemInfo span { display: block; }
        .itemCost { color: #ffff00; }
        .itemStock { color: #aaa; font-size: 12px; }
        .buyButton { padding: 8px 15px; font-size: 14px; min-width: 80px; }
        #storeContinueButton { display: block; margin: 25px auto 0 auto; }
    </style>
</head>
<body>

    <div id="startMenuContainer">
        <h1 id="mainTitle">MISSILE COMMAND</h1>
        <div id="difficultySelection">
            <h3>SELECT DIFFICULTY</h3>
            <button class="difficulty-button" data-ammo="150">Level 1 (150 Ammo)</button>
            <button class="difficulty-button" data-ammo="125">Level 2 (125 Ammo)</button>
            <button class="difficulty-button" data-ammo="100">Level 3 (100 Ammo)</button>
            <button class="difficulty-button" data-ammo="80">Level 4 (80 Ammo)</button>
            <button class="difficulty-button" data-ammo="60">Level 5 (60 Ammo)</button>
        </div>
        <button id="actualStartButton">Start Game</button>
    </div>

    <div id="uiContainer">
        <div id="score">SCORE: 0</div>
        <div id="level">LEVEL: 1</div>
        <div id="citiesLeft">CITIES: 6</div>
        <div id="bonusIndicator">BONUS FIRE +0!</div>
    </div>

    <div style="position: relative;">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="pauseOverlay">PAUSED</div>
    </div>

    <div id="controlsContainer">
        <button id="restartButton" style="display: none;">Restart Game</button>
        <button id="pauseButton" style="display: none;">Pause</button>
        <button id="screenshotButton" style="display: none;">Save Screenshot</button>
    </div>

    <div id="messageBox">
        <h2 id="messageTitle"></h2>
        <p id="messageText"></p>
        <p id="messageSubText"></p>
        <p id="messageBonusText" class="bonus-alert"></p>
        <div class="messageBoxButtons">
            <button id="goToStoreButton">Go to Store</button>
            <button id="skipStoreButton">Next Level</button>
        </div>
    </div>

    <div id="storeModal">
        <h2>Inter-Level Store</h2>
        <div id="storeScore">Current Score: $0</div>
        <div class="storeItem">
            <div class="storeItemInfo">
                <span>Satellite Base (Max 3 Active)</span>
                <span class="itemCost">Cost: $4000</span>
                <span class="itemStock" id="stockSatellite">Stock: 6</span>
            </div>
            <button class="buyButton" id="buySatelliteButton">BUY</button>
        </div>
         <div class="storeItem">
            <div class="storeItemInfo">
                <span>Satellite Shield (Max 3 Active)</span> 
                <span class="itemCost">Cost: $250</span>
                <span class="itemStock" id="stockSatShield">Stock: 100</span>
            </div>
            <button class="buyButton" id="buySatShieldButton">BUY</button> 
        </div>
        <div class="storeItem">
            <div class="storeItemInfo">
                <span>Replacement Base</span>
                <span class="itemCost">Cost: $1000</span>
                <span class="itemStock" id="stockBase">Stock: 6</span>
            </div>
            <button class="buyButton" id="buyBaseButton">BUY</button>
        </div>
        <div class="storeItem">
            <div class="storeItemInfo">
                <span>Replacement City</span>
                <span class="itemCost">Cost: $2000</span>
                <span class="itemStock" id="stockCity">Stock: 6</span>
            </div>
            <button class="buyButton" id="buyCityButton">BUY</button>
        </div>
        <div class="storeItem">
            <div class="storeItemInfo">
                <span>Base Shield (Max 3 Active)</span>
                <span class="itemCost">Cost: $250</span>
                <span class="itemStock" id="stockShield">Stock: 100</span>
            </div>
            <button class="buyButton" id="buyShieldButton">BUY</button>
        </div>
        <button id="storeContinueButton">Continue to Next Level</button>
    </div>


    <script>
        // --- Canvas, Context, UI Elements ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score'); const levelDisplay = document.getElementById('level'); const citiesLeftDisplay = document.getElementById('citiesLeft'); const restartButton = document.getElementById('restartButton'); const pauseButton = document.getElementById('pauseButton'); const screenshotButton = document.getElementById('screenshotButton'); const messageBox = document.getElementById('messageBox'); const messageTitle = document.getElementById('messageTitle'); const messageText = document.getElementById('messageText'); const messageSubText = document.getElementById('messageSubText'); const messageBonusText = document.getElementById('messageBonusText'); const pauseOverlay = document.getElementById('pauseOverlay'); const uiContainer = document.getElementById('uiContainer'); const controlsContainer = document.getElementById('controlsContainer'); const difficultySelectionDiv = document.getElementById('difficultySelection'); const startMenuContainer = document.getElementById('startMenuContainer'); const actualStartButton = document.getElementById('actualStartButton'); const bonusIndicator = document.getElementById('bonusIndicator');
        const goToStoreButton = document.getElementById('goToStoreButton'); const skipStoreButton = document.getElementById('skipStoreButton');
        const storeModal = document.getElementById('storeModal'); const storeScoreDisplay = document.getElementById('storeScore'); const stockSatelliteDisplay = document.getElementById('stockSatellite'); const stockBaseDisplay = document.getElementById('stockBase'); const stockCityDisplay = document.getElementById('stockCity'); const stockShieldDisplay = document.getElementById('stockShield'); const stockSatShieldDisplay = document.getElementById('stockSatShield'); /* New */ const buySatelliteButton = document.getElementById('buySatelliteButton'); const buyBaseButton = document.getElementById('buyBaseButton'); const buyCityButton = document.getElementById('buyCityButton'); const buyShieldButton = document.getElementById('buyShieldButton'); const buySatShieldButton = document.getElementById('buySatShieldButton'); /* New */ const storeContinueButton = document.getElementById('storeContinueButton');

        // --- Game Constants & State Variables ---
        const GROUND_HEIGHT = 50; const BASE_WIDTH = 40; const BASE_HEIGHT = 25; const CITY_WIDTH = 50; const CITY_HEIGHT = 30; const MISSILE_SPEED_PLAYER = 5; const MISSILE_SPEED_ENEMY_BASE = 0.5; const EXPLOSION_RADIUS_START = 5; const EXPLOSION_RADIUS_MAX = 40; const EXPLOSION_DURATION = 45; const POINTS_PER_MISSILE = 25; const POINTS_PER_CITY = 100; const POINTS_PER_AMMO = 5; const MISSILES_PER_LEVEL_BASE = 8; let selectedDifficultyAmmo = 60; const BONUS_FIRE_SPREAD = 8;
        const COST_SATELLITE = 4000; const COST_BASE = 1000; const COST_CITY = 2000; const COST_SHIELD = 250; const COST_SAT_SHIELD = 250; /* New */ const MAX_STOCK = 6; const MAX_SHIELD_STOCK = 100; const MAX_SAT_SHIELD_STOCK = 100; /* New */ const MAX_ACTIVE_SATELLITES = 3; const SATELLITE_Y_POS = canvas.height * 0.4; const SATELLITE_WIDTH = 35; const SATELLITE_HEIGHT = 25;
        const SHIELD_STRENGTH_START = 100; const SHIELD_DAMAGE_PER_HIT = 25;
        const SHIELD_COLOR_FULL = 'rgba(0, 150, 255, 0.6)'; const SHIELD_COLOR_75 = 'rgba(0, 255, 150, 0.6)'; const SHIELD_COLOR_50 = 'rgba(255, 255, 0, 0.6)'; const SHIELD_COLOR_25 = 'rgba(255, 100, 0, 0.6)'; const SHIELD_FLASH_COLOR = 'rgba(255, 255, 255, 0.8)'; const SHIELD_FLASH_DURATION = 5;

        let score = 0; let level = 1; let cities = []; let bases = []; let incomingMissiles = []; let playerMissiles = []; let explosions = []; let isGameOver = true; let gameLoopId = null; let missilesToSpawn = 0; let enemyMissileSpeed = MISSILE_SPEED_ENEMY_BASE; let transitioningLevel = false; let isPaused = false; let gameHasStarted = false; let difficultySelected = false; let bonusMissileCount = 0;
        let storeStockSatellite = MAX_STOCK; let storeStockBase = MAX_STOCK; let storeStockCity = MAX_STOCK; let storeStockShield = MAX_SHIELD_STOCK; let storeStockSatShield = MAX_SAT_SHIELD_STOCK; /* New */
        let satelliteBases = [];
        let baseShields = [null, null, null];

        // --- Utility Functions ---
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function getRandomTarget() { const aliveCities = cities.filter(c => c.alive); const aliveBases = bases.filter(b => b.alive); const aliveSatellites = satelliteBases.filter(s => s.alive); let possibleTargets = [...aliveCities, ...aliveBases, ...aliveSatellites]; if (possibleTargets.length === 0) { return { x: canvas.width / 2, y: canvas.height - GROUND_HEIGHT }; } const target = possibleTargets[Math.floor(Math.random() * possibleTargets.length)]; return { x: target.x + (target.width / 2), y: target.y }; }

        // --- Game Object Factories ---
        function createCity(x) { const buildings = []; const numBuildings = 3 + Math.floor(Math.random() * 3); let currentX = x; const totalBuildingWidth = CITY_WIDTH * 0.9; const baseBuildingWidth = totalBuildingWidth / numBuildings; for (let i = 0; i < numBuildings; i++) { const buildingHeight = (CITY_HEIGHT * 0.6) + (Math.random() * CITY_HEIGHT * 0.4); const buildingWidth = baseBuildingWidth * (0.8 + Math.random() * 0.4); const gap = (baseBuildingWidth - buildingWidth) / 2; buildings.push({ x: currentX + gap, y: canvas.height - GROUND_HEIGHT - buildingHeight, w: buildingWidth, h: buildingHeight, color: `hsl(180, 100%, ${35 + Math.random() * 15}%)` }); currentX += baseBuildingWidth; } return { x: x, y: canvas.height - GROUND_HEIGHT - CITY_HEIGHT, width: CITY_WIDTH, height: CITY_HEIGHT, alive: true, buildings: buildings, draw() { if (!this.alive) return; this.buildings.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.w, b.h); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; const windowSize = Math.min(b.w, b.h) * 0.15; const cols = Math.floor(b.w / (windowSize * 2.5)); const rows = Math.floor(b.h / (windowSize * 3)); if (cols > 0 && rows > 0) { const xSpacing = b.w / cols; const ySpacing = b.h / rows; for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { ctx.fillRect( b.x + xSpacing * (c + 0.5) - windowSize / 2, b.y + ySpacing * (r + 0.5) - windowSize / 2, windowSize, windowSize ); } } } ctx.strokeStyle = '#006666'; ctx.lineWidth = 1; ctx.strokeRect(b.x, b.y, b.w, b.h); }); } }; }
        function createBase(x) { const baseY = canvas.height - GROUND_HEIGHT - BASE_HEIGHT; return { x: x, y: baseY, width: BASE_WIDTH, height: BASE_HEIGHT, color: '#dddd00', outlineColor: '#aaaa00', launcherColor: '#999999', alive: true, ammo: selectedDifficultyAmmo, isSatellite: false, draw() { if (!this.alive) return; ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(this.x, this.y + this.height); ctx.lineTo(this.x + this.width * 0.2, this.y); ctx.lineTo(this.x + this.width * 0.8, this.y); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.closePath(); ctx.fill(); ctx.strokeStyle = this.outlineColor; ctx.lineWidth = 2; ctx.stroke(); const launcherWidth = this.width * 0.15; const launcherHeight = this.height * 0.4; ctx.fillStyle = this.launcherColor; ctx.fillRect( this.x + this.width / 2 - launcherWidth / 2, this.y - launcherHeight, launcherWidth, launcherHeight ); ctx.fillStyle = '#666666'; ctx.fillRect( this.x + this.width / 2 - launcherWidth / 2, this.y - launcherHeight * 0.3, launcherWidth, 2 ); ctx.fillStyle = '#000'; ctx.font = '12px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.ammo, this.x + this.width / 2, this.y + this.height / 2); } }; }
        // Added shield property to satellite
        function createSatelliteBase(x, y) {
             return {
                x: x, y: y, width: SATELLITE_WIDTH, height: SATELLITE_HEIGHT,
                bodyColor: '#b0b0b0', panelColor: '#3333cc', panelHighlight: '#6666ff', outlineColor: '#777777', antennaColor: '#dddddd', lightColor: '#ff0000',
                alive: true, ammo: selectedDifficultyAmmo, isSatellite: true,
                shield: null, // *** Initialize shield state ***
                draw() {
                    if (!this.alive) return;
                    const bodyW = this.width * 0.5; const bodyH = this.height; const bodyX = this.x + (this.width - bodyW) / 2; const panelW = this.width * 0.25; const panelH = this.height * 0.8; const panelY = this.y + (bodyH - panelH) / 2;
                    // Draw Panels
                    ctx.fillStyle = this.panelColor; ctx.fillRect(this.x, panelY, panelW, panelH); ctx.fillRect(this.x + this.width - panelW, panelY, panelW, panelH); ctx.strokeStyle = this.panelHighlight; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.x + panelW / 2, panelY); ctx.lineTo(this.x + panelW / 2, panelY + panelH); ctx.moveTo(this.x + this.width - panelW / 2, panelY); ctx.lineTo(this.x + this.width - panelW / 2, panelY + panelH); ctx.moveTo(this.x, panelY + panelH / 3); ctx.lineTo(this.x + panelW, panelY + panelH / 3); ctx.moveTo(this.x, panelY + panelH * 2/3); ctx.lineTo(this.x + panelW, panelY + panelH * 2/3); ctx.moveTo(this.x + this.width - panelW, panelY + panelH / 3); ctx.lineTo(this.x + this.width, panelY + panelH / 3); ctx.moveTo(this.x + this.width - panelW, panelY + panelH * 2/3); ctx.lineTo(this.x + this.width, panelY + panelH * 2/3); ctx.stroke();
                    // Draw Body
                    ctx.fillStyle = this.bodyColor; ctx.beginPath(); ctx.moveTo(bodyX, this.y + bodyH * 0.2); ctx.lineTo(bodyX + bodyW * 0.1, this.y); ctx.lineTo(bodyX + bodyW * 0.9, this.y); ctx.lineTo(bodyX + bodyW, this.y + bodyH * 0.2); ctx.lineTo(bodyX + bodyW, this.y + bodyH * 0.8); ctx.lineTo(bodyX + bodyW * 0.9, this.y + bodyH); ctx.lineTo(bodyX + bodyW * 0.1, this.y + bodyH); ctx.lineTo(bodyX, this.y + bodyH * 0.8); ctx.closePath(); ctx.fill(); ctx.strokeStyle = this.outlineColor; ctx.lineWidth = 1; ctx.stroke();
                    // Draw Antenna
                    const dishRadius = bodyW * 0.3; const dishY = this.y - dishRadius * 0.6; ctx.strokeStyle = this.antennaColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(bodyX + bodyW / 2, dishY, dishRadius, Math.PI * 1.1, Math.PI * 1.9); ctx.stroke(); ctx.beginPath(); ctx.moveTo(bodyX + bodyW / 2, this.y); ctx.lineTo(bodyX + bodyW / 2, dishY); ctx.stroke();
                    // Draw Nozzle
                    const nozzleWidth = bodyW * 0.2; const nozzleHeight = bodyH * 0.25; ctx.fillStyle = this.outlineColor; ctx.fillRect(bodyX + (bodyW / 2) - (nozzleWidth / 2), this.y + bodyH, nozzleWidth, nozzleHeight);
                    // Draw Light
                    ctx.fillStyle = this.lightColor; if (Math.floor(Date.now() / 500) % 2 === 0) { ctx.beginPath(); ctx.arc(bodyX + bodyW / 2, this.y + bodyH / 2, 2, 0, Math.PI * 2); ctx.fill(); }
                    // Draw Ammo
                    ctx.fillStyle = '#ffff00'; ctx.font = '10px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText(this.ammo, this.x + this.width / 2, this.y + bodyH + nozzleHeight + 3);
                }
            };
        }
        function createIncomingMissile() { const startX = Math.random() * canvas.width; const target = getRandomTarget(); const angle = Math.atan2(target.y - 0, target.x - startX); return { x: startX, y: 0, targetX: target.x, targetY: target.y, dx: Math.cos(angle) * enemyMissileSpeed, dy: Math.sin(angle) * enemyMissileSpeed, color: '#ff0000', trailColor: 'rgba(255, 100, 100, 0.5)', alive: true, trail: [{x: startX, y: 0}], update() { if (!this.alive) return; this.x += this.dx; this.y += this.dy; this.trail.push({x: this.x, y: this.y}); if (this.trail.length > 15) { this.trail.shift(); } if (this.y >= this.targetY || this.y >= canvas.height - GROUND_HEIGHT) { this.alive = false; const impactY = Math.min(this.targetY, canvas.height - GROUND_HEIGHT); createExplosion(this.x, impactY, EXPLOSION_RADIUS_MAX / 2, this.color); checkObjectImpact(this.x, impactY); } }, draw() { if (!this.alive) return; ctx.strokeStyle = this.trailColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke(); ctx.fillStyle = this.color; ctx.fillRect(this.x - 2, this.y - 2, 4, 4); } }; }
        function createPlayerMissile(startX, startY, targetX, targetY) { const angle = Math.atan2(targetY - startY, targetX - startX); return { x: startX, y: startY, targetX: targetX, targetY: targetY, dx: Math.cos(angle) * MISSILE_SPEED_PLAYER, dy: Math.sin(angle) * MISSILE_SPEED_PLAYER, color: '#00ff00', trailColor: 'rgba(100, 255, 100, 0.5)', alive: true, trail: [{x: startX, y: startY}], update() { if (!this.alive) return; this.x += this.dx; this.y += this.dy; this.trail.push({x: this.x, y: this.y}); if (this.trail.length > 10) { this.trail.shift(); } const distToTarget = distance(this.x, this.y, this.targetX, this.targetY); const distTraveled = distance(startX, startY, this.x, this.y); const totalDist = distance(startX, startY, this.targetX, this.targetY); if (distTraveled >= totalDist || distToTarget < MISSILE_SPEED_PLAYER) { this.alive = false; createExplosion(this.targetX, this.targetY, EXPLOSION_RADIUS_START, this.color); } }, draw() { if (!this.alive) return; ctx.strokeStyle = this.trailColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke(); ctx.fillStyle = this.color; ctx.fillRect(this.x - 1, this.y - 1, 3, 3); } }; }
        function createExplosion(x, y, startRadius, color) { if (typeof color !== 'string' || !color.startsWith('#')) { console.warn("Invalid color passed to createExplosion:", color, "Using default grey."); color = '#888888'; } explosions.push({ x: x, y: y, radius: startRadius, maxRadius: EXPLOSION_RADIUS_MAX, duration: EXPLOSION_DURATION, currentFrame: 0, color: color, alive: true, update() { if (!this.alive) return; this.currentFrame++; const expansionPhase = EXPLOSION_DURATION * 0.6; if (this.currentFrame <= expansionPhase) { this.radius = startRadius + (this.maxRadius - startRadius) * (this.currentFrame / expansionPhase); } else { this.radius = this.maxRadius - (this.maxRadius * ((this.currentFrame - expansionPhase) / (EXPLOSION_DURATION - expansionPhase))); } this.radius = Math.max(0, this.radius); if (this.currentFrame >= this.duration) { this.alive = false; } if(this.currentFrame < expansionPhase) { checkExplosionCollisions(this); } }, draw() { if (!this.alive) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); const intensity = Math.sin((this.currentFrame / this.duration) * Math.PI); const r = parseInt(this.color.slice(1, 3), 16); const g = parseInt(this.color.slice(3, 5), 16); const b = parseInt(this.color.slice(5, 7), 16); ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + intensity * 0.6})`; ctx.fill(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.3 * intensity, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.8})`; ctx.fill(); } }); }

        // --- Collision Detection ---
        function checkExplosionCollisions(explosion) { incomingMissiles.forEach(missile => { if (missile.alive) { const dist = distance(explosion.x, explosion.y, missile.x, missile.y); if (dist < explosion.radius) { missile.alive = false; score += POINTS_PER_MISSILE; createExplosion(missile.x, missile.y, EXPLOSION_RADIUS_START, missile.color); } } }); }
        // Updated checkObjectImpact for base shields and satellite shields
        function checkObjectImpact(impactX, impactY) {
            // Check Base Shields FIRST
            for (let i = 0; i < baseShields.length; i++) {
                const shield = baseShields[i];
                if (shield && shield.alive) {
                    const base = bases[i];
                    const shieldCenterX = base.x + base.width / 2;
                    const shieldRadius = (base.width / 2) + CITY_WIDTH / 2 + 5;
                    const shieldTopY = base.y - shieldRadius * 0.5;
                    const shieldLeftX = shieldCenterX - shieldRadius;
                    const shieldRightX = shieldCenterX + shieldRadius;
                    const shieldBottomY = base.y;
                    if (impactX >= shieldLeftX && impactX <= shieldRightX && impactY >= shieldTopY && impactY <= shieldBottomY) {
                        shield.strength -= SHIELD_DAMAGE_PER_HIT; shield.flashTimer = SHIELD_FLASH_DURATION;
                        if (shield.strength <= 0) { shield.alive = false; createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 1.5, '#ffffff'); }
                        else { createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 0.5, SHIELD_FLASH_COLOR); }
                        return; // Shield took the hit
                    }
                }
            }

            // Check Satellite Shields SECOND
            for (let i = 0; i < satelliteBases.length; i++) {
                 const sat = satelliteBases[i];
                 if (sat.alive && sat.shield && sat.shield.alive) {
                     const shieldCenterX = sat.x + sat.width / 2;
                     const shieldCenterY = sat.y + sat.height / 2;
                     const shieldRadiusX = sat.width * 0.6 + 4; // Ellipse radius X (a bit wider)
                     const shieldRadiusY = sat.height * 0.8 + 4; // Ellipse radius Y (a bit taller)

                     // Ellipse collision check: ((x-h)/rx)^2 + ((y-k)/ry)^2 <= 1
                     const dx = impactX - shieldCenterX;
                     const dy = impactY - shieldCenterY;
                     if (((dx * dx) / (shieldRadiusX * shieldRadiusX)) + ((dy * dy) / (shieldRadiusY * shieldRadiusY)) <= 1) {
                         // Hit the satellite shield!
                         sat.shield.strength -= SHIELD_DAMAGE_PER_HIT;
                         sat.shield.flashTimer = SHIELD_FLASH_DURATION;
                         console.log(`Satellite Shield ${i} hit! Strength: ${sat.shield.strength}`);
                         if (sat.shield.strength <= 0) {
                             sat.shield.alive = false;
                             console.log(`Satellite Shield ${i} destroyed!`);
                             createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 1.2, '#eeeeee'); // Slightly smaller white explosion
                         } else {
                             createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 0.5, SHIELD_FLASH_COLOR);
                         }
                         return; // Shield took the hit
                     }
                 }
             }

            // If no shields hit, check actual objects
            satelliteBases.forEach(sat => { if (sat.alive && impactX >= sat.x && impactX <= sat.x + sat.width && impactY >= sat.y && impactY <= sat.y + sat.height) { sat.alive = false; createExplosion(impactX, impactY, EXPLOSION_RADIUS_START, sat.outlineColor); } });
            if (impactY >= canvas.height - GROUND_HEIGHT - CITY_HEIGHT) { cities.forEach(city => { if (city.alive && impactX >= city.x && impactX <= city.x + city.width) { city.alive = false; } }); }
            if (impactY >= canvas.height - GROUND_HEIGHT - BASE_HEIGHT) { bases.forEach(base => { if (base.alive && impactX >= base.x && impactX <= base.x + base.width) { if (impactY >= base.y) {base.alive = false;} } }); }
        }


        // --- Game Flow ---
        function initLevel() { incomingMissiles = []; playerMissiles = []; explosions = []; bases.forEach(b => { if (b.alive) b.ammo = selectedDifficultyAmmo; }); satelliteBases.forEach(s => { if (s.alive) s.ammo = selectedDifficultyAmmo; }); missilesToSpawn = MISSILES_PER_LEVEL_BASE + (level - 1) * 4; enemyMissileSpeed = MISSILE_SPEED_ENEMY_BASE + (level - 1) * 0.15; enemyMissileSpeed = Math.min(enemyMissileSpeed, 3.0); updateUI(); }
        function startGame() { if (!difficultySelected) { console.warn("Difficulty not selected!"); return; } score = 0; level = 1; isGameOver = false; isPaused = false; transitioningLevel = false; gameHasStarted = true; bonusMissileCount = 0; storeStockSatellite = MAX_STOCK; storeStockBase = MAX_STOCK; storeStockCity = MAX_STOCK; storeStockShield = MAX_SHIELD_STOCK; storeStockSatShield = MAX_SAT_SHIELD_STOCK; /* Reset */ satelliteBases = []; baseShields = [null, null, null];
            startMenuContainer.style.display = 'none'; canvas.style.display = 'block'; uiContainer.style.display = 'flex'; controlsContainer.style.display = 'flex'; screenshotButton.style.display = 'inline-block'; hideMessage(); pauseOverlay.style.display = 'none';
            cities = []; const citySpacing = (canvas.width - 6 * CITY_WIDTH) / 7; for (let i = 0; i < 3; i++) cities.push(createCity(citySpacing * (i + 1) + CITY_WIDTH * i)); for (let i = 0; i < 3; i++) cities.push(createCity(citySpacing * (i + 4) + CITY_WIDTH * (i + 3))); cities.forEach(c => c.alive = true);
            bases = []; const basePositions = [canvas.width * 0.15, canvas.width * 0.5, canvas.width * 0.85]; bases.push(createBase(basePositions[0] - BASE_WIDTH / 2)); bases.push(createBase(basePositions[1] - BASE_WIDTH / 2)); bases.push(createBase(basePositions[2] - BASE_WIDTH / 2)); bases.forEach(b => b.alive = true);
            initLevel(); restartButton.style.display = 'inline-block'; pauseButton.style.display = 'inline-block'; pauseButton.textContent = 'Pause'; pauseButton.disabled = false;
            if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
            gameLoop();
        }
        function nextLevel() { level++; let bonusEarned = calculateBonus(); score += bonusEarned; const citiesSurvived = cities.filter(c => c.alive).length; const citiesLost = 6 - citiesSurvived; let bonusChangeMsg = ""; if (citiesLost > 0) { const lostBonus = Math.min(bonusMissileCount, citiesLost); if (lostBonus > 0) { bonusChangeMsg = `Lost ${lostBonus} bonus missile${lostBonus > 1 ? 's' : ''}!`; bonusMissileCount -= lostBonus; } } else { bonusMissileCount++; bonusChangeMsg = `PERFECT! +1 Bonus Missile!`; } bonusMissileCount = Math.max(0, bonusMissileCount); if (bonusMissileCount > 0) { bonusChangeMsg += ` (Total +${bonusMissileCount} active next level)`; } else if (bonusChangeMsg !== "" && citiesLost > 0) { bonusChangeMsg += ` (Bonus Fire deactivated)`; } else { bonusChangeMsg = "";} showMessage(`LEVEL ${level - 1} CLEARED`, `Score Bonus: $${bonusEarned}`, "", bonusChangeMsg); goToStoreButton.style.display = 'inline-block'; skipStoreButton.style.display = 'inline-block'; pauseButton.disabled = true; }
        function proceedToNextLevel() { storeModal.style.display = 'none'; hideMessage(); initLevel(); transitioningLevel = false; pauseButton.disabled = false; if (!isPaused && !gameLoopId) { gameLoop(); } }
        function calculateBonus() { let bonus = 0; cities.forEach(city => { if (city.alive) bonus += POINTS_PER_CITY; }); bases.forEach(base => { if (base.alive) bonus += base.ammo * POINTS_PER_AMMO; }); satelliteBases.forEach(sat => { if (sat.alive) bonus += sat.ammo * POINTS_PER_AMMO; }); return bonus; }
        function checkLevelEnd() { if (transitioningLevel || isGameOver || isPaused) return; if (missilesToSpawn <= 0 && incomingMissiles.every(m => !m.alive) && explosions.every(e => !e.alive)) { transitioningLevel = true; nextLevel(); } }
        function checkGameOverConditions() { if (isGameOver || !gameHasStarted) return; const basesRemaining = bases.filter(b => b.alive).length; const citiesRemaining = cities.filter(c => c.alive).length; if (basesRemaining === 0 || citiesRemaining === 0) { gameOver(); } }
        function gameOver() { if (isGameOver) return; isGameOver = true; gameHasStarted = false; transitioningLevel = false; isPaused = false; bonusMissileCount = 0; baseShields = [null, null, null]; satelliteBases = []; /* Clear satellites too */ const basesRemaining = bases.filter(b => b.alive).length; const citiesRemaining = cities.filter(c => c.alive).length; let reason = ""; if (basesRemaining === 0 && citiesRemaining === 0) { reason = "All bases and cities destroyed!"; } else if (basesRemaining === 0) { reason = "All bases destroyed!"; } else if (citiesRemaining === 0) { reason = "All cities destroyed!"; } showMessage("GAME OVER", `Final Score: $${score}`, `${reason} Level: ${level}`); restartButton.style.display = 'inline-block'; pauseButton.style.display = 'inline-block'; pauseButton.textContent = 'Pause'; pauseButton.disabled = true; pauseOverlay.style.display = 'none'; bonusIndicator.style.display = 'none'; storeModal.style.display = 'none'; }

        // --- Pause/Resume Logic ---
        function pauseGame() { if (isGameOver || transitioningLevel || !gameHasStarted || storeModal.style.display === 'block' || messageBox.style.display === 'block') return; isPaused = true; pauseOverlay.style.display = 'flex'; pauseButton.textContent = 'Resume'; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } }
        function resumeGame() { if (isGameOver || transitioningLevel || !isPaused) return; isPaused = false; pauseOverlay.style.display = 'none'; pauseButton.textContent = 'Pause'; if (!gameLoopId) { gameLoop(); } }
        function togglePause() { if (isPaused) { resumeGame(); } else { pauseGame(); } }

        // --- Screenshot Logic ---
        async function saveScreenshot() { /* ... (no changes) ... */ const originalText = screenshotButton.textContent; screenshotButton.textContent = 'Saving...'; screenshotButton.disabled = true; try { if (!navigator.clipboard || !navigator.clipboard.write) { throw new Error('Clipboard API not supported or requires secure context (HTTPS/localhost).'); } canvas.toBlob(async (blob) => { if (!blob) { throw new Error('Canvas could not be converted to Blob.'); } try { const item = new ClipboardItem({ 'image/png': blob }); await navigator.clipboard.write([item]); screenshotButton.textContent = 'Copied!'; console.log('Screenshot copied to clipboard.'); } catch (err) { console.error('Failed to copy screenshot:', err); screenshotButton.textContent = 'Copy Failed!'; alert(`Failed to copy to clipboard:\n${err.message}\nMake sure you're on HTTPS/localhost and grant permission.`); } finally { setTimeout(() => { screenshotButton.textContent = originalText; screenshotButton.disabled = false; }, 2000); } }, 'image/png'); } catch (err) { console.error('Screenshot error:', err); screenshotButton.textContent = 'Error!'; alert(`Screenshot Error:\n${err.message}`); setTimeout(() => { screenshotButton.textContent = originalText; screenshotButton.disabled = false; }, 2000); } }

        // --- Message Display ---
        function showMessage(title, text, subtext = "", bonusAlert = "") { messageTitle.textContent = title; messageText.textContent = text; if (subtext) { messageSubText.textContent = subtext; messageSubText.style.display = 'block'; } else { messageSubText.style.display = 'none'; } if (bonusAlert) { messageBonusText.textContent = bonusAlert; messageBonusText.style.display = 'block'; } else { messageBonusText.style.display = 'none'; } goToStoreButton.style.display = 'none'; skipStoreButton.style.display = 'none'; messageBox.style.display = 'block'; }
        function hideMessage() { messageBox.style.display = 'none'; goToStoreButton.style.display = 'none'; skipStoreButton.style.display = 'none'; }

        // --- Store Logic ---
        function updateStoreUI() {
            storeScoreDisplay.textContent = `Current Score: $${score}`;
            stockSatelliteDisplay.textContent = `Stock: ${storeStockSatellite}`;
            stockBaseDisplay.textContent = `Stock: ${storeStockBase}`;
            stockCityDisplay.textContent = `Stock: ${storeStockCity}`;
            stockShieldDisplay.textContent = `Stock: ${storeStockShield}`;
            stockSatShieldDisplay.textContent = `Stock: ${storeStockSatShield}`; // Update sat shield stock

            const canRebuildBase = bases.some(b => !b.alive);
            const canRebuildCity = cities.some(c => !c.alive);
            const activeSatellites = satelliteBases.filter(s => s.alive).length;
            const canBuyShield = baseShields.some((shield, index) => bases[index].alive && (!shield || !shield.alive));
            // Check if any active satellite needs a shield
            const canBuySatShield = satelliteBases.some(s => s.alive && (!s.shield || !s.shield.alive));

            buySatelliteButton.disabled = score < COST_SATELLITE || storeStockSatellite <= 0 || activeSatellites >= MAX_ACTIVE_SATELLITES;
            buyBaseButton.disabled = score < COST_BASE || storeStockBase <= 0 || !canRebuildBase;
            buyCityButton.disabled = score < COST_CITY || storeStockCity <= 0 || !canRebuildCity;
            buyShieldButton.disabled = score < COST_SHIELD || storeStockShield <= 0 || !canBuyShield;
            buySatShieldButton.disabled = score < COST_SAT_SHIELD || storeStockSatShield <= 0 || !canBuySatShield; // Update sat shield button state
        }
        function findAndRebuildBase() { const deadBaseIndex = bases.findIndex(b => !b.alive); if (deadBaseIndex !== -1) { bases[deadBaseIndex].alive = true; bases[deadBaseIndex].ammo = selectedDifficultyAmmo; console.log(`Base at index ${deadBaseIndex} rebuilt.`); return true; } console.log("No dead bases found to rebuild."); return false; }
        function findAndRebuildCity() { const deadCityIndex = cities.findIndex(c => !c.alive); if (deadCityIndex !== -1) { cities[deadCityIndex].alive = true; console.log(`City at index ${deadCityIndex} rebuilt.`); return true; } console.log("No dead cities found to rebuild."); return false; }
        function buyReplacementBase() { if (score >= COST_BASE && storeStockBase > 0) { if (findAndRebuildBase()) { score -= COST_BASE; storeStockBase--; updateStoreUI(); updateUI(); } else { console.log("Purchase failed: No bases to rebuild."); } } else { console.log("Purchase failed: Cannot afford or out of stock."); } }
        function buyReplacementCity() { if (score >= COST_CITY && storeStockCity > 0) { if (findAndRebuildCity()) { score -= COST_CITY; storeStockCity--; updateStoreUI(); updateUI(); } else { console.log("Purchase failed: No cities to rebuild."); } } else { console.log("Purchase failed: Cannot afford or out of stock."); } }
        function buySatellite() { const activeSatellites = satelliteBases.filter(s => s.alive).length; if (score >= COST_SATELLITE && storeStockSatellite > 0 && activeSatellites < MAX_ACTIVE_SATELLITES) { let placed = false; for (let i = 0; i < 3; i++) { const groundBaseXCenter = bases[i].x + bases[i].width / 2; const satelliteX = groundBaseXCenter - SATELLITE_WIDTH / 2; const positionOccupied = satelliteBases.some(s => s.alive && Math.abs(s.x - satelliteX) < 1); if (!positionOccupied) { score -= COST_SATELLITE; storeStockSatellite--; const newSatellite = createSatelliteBase(satelliteX, SATELLITE_Y_POS); satelliteBases.push(newSatellite); console.log(`Satellite purchased and placed at slot ${i}`); placed = true; break; } } if (!placed) { console.log("Purchase failed: Could not find placement slot."); } updateStoreUI(); updateUI(); } else { console.log("Purchase failed: Cannot afford, out of stock, or max satellites active."); } }
        function buyShield() { if (score >= COST_SHIELD && storeStockShield > 0) { let shieldPlaced = false; for (let i = 0; i < bases.length; i++) { if (bases[i].alive && (!baseShields[i] || !baseShields[i].alive)) { score -= COST_SHIELD; storeStockShield--; baseShields[i] = { alive: true, strength: SHIELD_STRENGTH_START, flashTimer: 0 }; console.log(`Shield purchased for base ${i}`); shieldPlaced = true; break; } } if (!shieldPlaced) { console.log("Purchase failed: No available base for a shield."); } updateStoreUI(); updateUI(); } else { console.log("Purchase failed: Cannot afford or out of stock."); } }
        // *** NEW Buy Satellite Shield Logic ***
        function buySatShield() {
             if (score >= COST_SAT_SHIELD && storeStockSatShield > 0) {
                 let shieldPlaced = false;
                 // Find first active satellite without an active shield
                 for (let i = 0; i < satelliteBases.length; i++) {
                     const sat = satelliteBases[i];
                     if (sat.alive && (!sat.shield || !sat.shield.alive)) {
                         score -= COST_SAT_SHIELD;
                         storeStockSatShield--;
                         sat.shield = { alive: true, strength: SHIELD_STRENGTH_START, flashTimer: 0 };
                         console.log(`Shield purchased for satellite ${i}`);
                         shieldPlaced = true;
                         break; // Only apply to one per purchase
                     }
                 }
                 if (!shieldPlaced) {
                     console.log("Purchase failed: No available satellite for a shield.");
                 }
                 updateStoreUI();
                 updateUI();
             } else {
                 console.log("Purchase failed: Cannot afford or out of stock.");
             }
        }

        // --- Drawing Functions ---
        function drawBackground() { ctx.fillStyle = '#00001a'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; for (let i = 0; i < 100; i++) { let x = Math.random() * canvas.width; let y = Math.random() * (canvas.height - GROUND_HEIGHT); let radius = Math.random() * 1.5; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill(); } ctx.fillStyle = '#3b2e1a'; ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT); }
        // Updated drawGameObjects to draw satellite shields
        function drawGameObjects() {
            cities.forEach(city => city.draw());
            bases.forEach(base => base.draw());
            // Draw Satellites AND their shields
            satelliteBases.forEach(sat => {
                sat.draw(); // Draw satellite body first
                // Draw satellite shield if active
                if (sat.shield && sat.shield.alive) {
                    const shieldCenterX = sat.x + sat.width / 2;
                    const shieldCenterY = sat.y + sat.height / 2;
                    const shieldRadiusX = sat.width * 0.6 + 4;
                    const shieldRadiusY = sat.height * 0.8 + 4;

                    let shieldColor = SHIELD_COLOR_25;
                    if (sat.shield.strength > 75) shieldColor = SHIELD_COLOR_FULL;
                    else if (sat.shield.strength > 50) shieldColor = SHIELD_COLOR_75;
                    else if (sat.shield.strength > 25) shieldColor = SHIELD_COLOR_50;

                    if (sat.shield.flashTimer > 0) {
                         shieldColor = SHIELD_FLASH_COLOR;
                         sat.shield.flashTimer--;
                    }

                    ctx.beginPath();
                    ctx.ellipse(shieldCenterX, shieldCenterY, shieldRadiusX, shieldRadiusY, 0, 0, Math.PI * 2); // Full ellipse
                    ctx.strokeStyle = shieldColor;
                    ctx.lineWidth = 2; // Slightly thinner than base shield
                    ctx.stroke();
                    ctx.lineWidth = 1; // Reset
                }
            });

            // Draw Base Shields (drawn after bases/satellites)
            for (let i = 0; i < baseShields.length; i++) { /* ... (shield drawing logic remains same) ... */ const shield = baseShields[i]; if (shield && shield.alive) { const base = bases[i]; const shieldCenterX = base.x + base.width / 2; const shieldRadius = (base.width / 2) + CITY_WIDTH / 2 + 5; const shieldTopY = base.y - shieldRadius * 0.1; let shieldColor = SHIELD_COLOR_25; if (shield.strength > 75) shieldColor = SHIELD_COLOR_FULL; else if (shield.strength > 50) shieldColor = SHIELD_COLOR_75; else if (shield.strength > 25) shieldColor = SHIELD_COLOR_50; if (shield.flashTimer > 0) { shieldColor = SHIELD_FLASH_COLOR; shield.flashTimer--; } ctx.beginPath(); ctx.arc(shieldCenterX, base.y, shieldRadius, Math.PI * 1.05, Math.PI * 1.95); ctx.strokeStyle = shieldColor; ctx.lineWidth = 3; ctx.stroke(); ctx.lineWidth = 1; } }

            incomingMissiles.forEach(missile => missile.draw());
            playerMissiles.forEach(missile => missile.draw());
            explosions.forEach(explosion => explosion.draw());
        }

        // --- Update Functions ---
        function updateGameObjects() { if (!isGameOver && !transitioningLevel && missilesToSpawn > 0 && Math.random() < 0.015 * (1 + level * 0.1)) { incomingMissiles.push(createIncomingMissile()); missilesToSpawn--; } incomingMissiles.forEach(missile => missile.update()); playerMissiles.forEach(missile => missile.update()); explosions.forEach(explosion => explosion.update()); incomingMissiles = incomingMissiles.filter(missile => missile.alive); playerMissiles = playerMissiles.filter(missile => missile.alive); explosions = explosions.filter(explosion => explosion.alive); }
        function updateUI() { scoreDisplay.textContent = `SCORE: $${score}`; levelDisplay.textContent = `LEVEL: ${level}`; const livingCities = cities.filter(c => c.alive).length; citiesLeftDisplay.textContent = `CITIES: ${livingCities}`; if (bonusMissileCount > 0) { bonusIndicator.textContent = `BONUS FIRE +${bonusMissileCount}!`; bonusIndicator.style.display = 'inline-block'; } else { bonusIndicator.style.display = 'none'; } }

        // --- Game Loop ---
        function gameLoop() { if (isPaused) { gameLoopId = null; return; } checkGameOverConditions(); if (isGameOver && explosions.length === 0 && !transitioningLevel) { if (!gameHasStarted) { /* Handled by onload */ } gameLoopId = null; return; } drawBackground(); if (!isGameOver && !transitioningLevel) { updateGameObjects(); } explosions.forEach(explosion => explosion.update()); explosions = explosions.filter(explosion => explosion.alive); drawGameObjects(); updateUI(); if (!isGameOver && !transitioningLevel) { checkLevelEnd(); } if (!isGameOver || explosions.length > 0) { gameLoopId = requestAnimationFrame(gameLoop); } else { gameLoopId = null; } }

        // --- Event Listeners ---
        canvas.addEventListener('click', (event) => { if (isGameOver || isPaused || transitioningLevel || !gameHasStarted) return; const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const clickX = (event.clientX - rect.left) * scaleX; const clickY = (event.clientY - rect.top) * scaleY; if (clickY < 20 || clickY > canvas.height - GROUND_HEIGHT) return; let nearestSource = null; let minDistance = Infinity; bases.forEach(base => { if (base.alive && base.ammo > 0) { const sourceCenterX = base.x + base.width / 2; const sourceTopY = base.y; const d = distance(clickX, clickY, sourceCenterX, sourceTopY); if (d < minDistance) { minDistance = d; nearestSource = base; } } }); satelliteBases.forEach(sat => { if (sat.alive && sat.ammo > 0) { const sourceCenterX = sat.x + sat.width / 2; const sourceTopY = sat.y + sat.height; const d = distance(clickX, clickY, sourceCenterX, sourceTopY); if (d < minDistance) { minDistance = d; nearestSource = sat; } } }); if (nearestSource) { const startX = nearestSource.x + nearestSource.width / 2; const startY = nearestSource.isSatellite ? nearestSource.y + nearestSource.height : nearestSource.y; const totalMissilesToFire = 1 + bonusMissileCount; const actualMissilesToFire = Math.min(totalMissilesToFire, nearestSource.ammo); if (actualMissilesToFire > 0) { nearestSource.ammo -= actualMissilesToFire; for (let i = 0; i < actualMissilesToFire; i++) { const currentOffset = (i - (actualMissilesToFire - 1) / 2) * BONUS_FIRE_SPREAD; playerMissiles.push(createPlayerMissile(startX + currentOffset, startY, clickX, clickY)); } } } });
        restartButton.addEventListener('click', () => { if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } isGameOver = true; gameHasStarted = false; isPaused = false; transitioningLevel = false; difficultySelected = false; bonusMissileCount = 0; storeStockSatellite = MAX_STOCK; storeStockBase = MAX_STOCK; storeStockCity = MAX_STOCK; storeStockShield = MAX_SHIELD_STOCK; storeStockSatShield = MAX_SAT_SHIELD_STOCK; /* Reset */ satelliteBases = []; baseShields = [null, null, null]; startMenuContainer.style.display = 'flex'; canvas.style.display = 'none'; uiContainer.style.display = 'none'; controlsContainer.style.display = 'none'; pauseOverlay.style.display = 'none'; hideMessage(); actualStartButton.style.display = 'none'; document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('selected')); bonusIndicator.style.display = 'none'; storeModal.style.display = 'none';});
        pauseButton.addEventListener('click', togglePause); screenshotButton.addEventListener('click', saveScreenshot);
        storeContinueButton.addEventListener('click', proceedToNextLevel); buyBaseButton.addEventListener('click', buyReplacementBase); buyCityButton.addEventListener('click', buyReplacementCity); buySatelliteButton.addEventListener('click', buySatellite); buyShieldButton.addEventListener('click', buyShield); buySatShieldButton.addEventListener('click', buySatShield); /* Added listener */
        goToStoreButton.addEventListener('click', () => { hideMessage(); updateStoreUI(); storeModal.style.display = 'block'; });
        skipStoreButton.addEventListener('click', proceedToNextLevel);
        document.querySelectorAll('.difficulty-button').forEach(button => { button.addEventListener('click', (event) => { selectedDifficultyAmmo = parseInt(event.target.getAttribute('data-ammo'), 10); difficultySelected = true; document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('selected')); event.target.classList.add('selected'); actualStartButton.style.display = 'inline-block'; actualStartButton.disabled = false; }); });
        actualStartButton.addEventListener('click', () => { if (difficultySelected) { startGame(); } else { console.warn("Please select a difficulty first."); } });
        window.addEventListener('keydown', (event) => { if (event.code === 'Space' && !isGameOver && !transitioningLevel && gameHasStarted && storeModal.style.display === 'none' && messageBox.style.display === 'none' ) { event.preventDefault(); togglePause(); } });

        // --- Initial Setup ---
        window.onload = () => { startMenuContainer.style.display = 'flex'; canvas.style.display = 'none'; uiContainer.style.display = 'none'; controlsContainer.style.display = 'none'; messageBox.style.display = 'none'; actualStartButton.style.display = 'none'; restartButton.style.display = 'none'; pauseButton.style.display = 'none'; screenshotButton.style.display = 'none'; bonusIndicator.style.display = 'none'; storeModal.style.display = 'none'; };

    </script>

</body>
</html>
