<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="Missile Command - Atari Classic Clone Game">
    <meta name="theme-color" content="#000000"/>
    <link rel="preload" href="/css/fonts.css" as="style">
    <link rel="preload" href="/fonts/press-start-2p-v15-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.json">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Missile Cmd">
    <title>Missile Command</title>
    <link href="/css/fonts.css" rel="stylesheet">
    <style>
        /* --- General Body and Font --- */
        html, body {
            height: 100%; /* Ensure body takes full height */
            margin: 0;
            padding: 0;
            /* Changed overflow to auto to allow scrolling if footer makes page long */
            overflow-x: hidden;
            overflow-y: auto;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the top */
            padding: 10px; /* Add some padding around the edges */
            box-sizing: border-box; /* Include padding in width/height */
            min-height: 100vh;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            color: #00ff00;
        }

        /* --- Game Title --- */
        h1#mainTitle {
            color: #ff0000;
            font-size: clamp(20px, 5vw, 32px); /* Responsive font size */
            margin-bottom: 15px;
            text-shadow: 2px 2px #ffff00;
            text-align: center; /* Center title */
        }

        /* --- Game Canvas Container --- */
        #canvasContainer {
            position: relative; /* Needed for absolute positioning of overlays */
            width: 100%;
            max-width: 800px; /* Max width like original */
            aspect-ratio: 800 / 600;
            margin: 0 auto; /* Center the container */
        }

        /* --- Game Canvas --- */
        #gameCanvas {
            display: none; /* Hidden initially */
            background-color: #111;
            border: 2px solid #00ff00;
            box-shadow: 0 0 15px #00ff00;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* --- UI Container (Score, Level, etc.) --- */
        #uiContainer {
            display: none; /* Hidden initially */
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 8px 0;
            font-size: clamp(10px, 2.5vw, 14px);
            gap: 10px;
        }
        #bonusIndicator {
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 1px 1px #000;
            display: none;
            order: 5;
            text-align: center;
        }

        /* --- Controls Container (Buttons below canvas) --- */
        #controlsContainer {
            margin-top: 10px;
            display: none; /* Hidden initially */
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            width: 100%;
            max-width: 800px;
        }

        /* --- Special Weapons UI Area --- */
        #specialWeaponsUI {
            background-color: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 8px 10px;
            margin-top: 10px;
            display: none; /* Hidden initially */
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            width: auto;
            max-width: 95%;
        }
        .weaponControl {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            border: 2px solid transparent;
            padding: 5px;
            border-radius: 5px;
            transition: border-color 0.3s, background-color 0.3s;
        }
        .weaponControl.armed {
             border-color: #ff0000;
             background-color: rgba(255, 0, 0, 0.2);
        }
         .weaponControl:hover:not(.disabled) {
             background-color: rgba(0, 255, 0, 0.1);
         }
        .weaponControl.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .weaponIcon {
            font-size: clamp(18px, 4vw, 24px);
             width: 30px;
             height: 30px;
             line-height: 30px;
             text-align: center;
             border: 1px solid #888;
             border-radius: 4px;
             margin-bottom: 4px;
        }
        .weaponCount {
            font-size: clamp(10px, 2vw, 12px);
            color: #ffff00;
        }

        /* --- Start Menu --- */
        #startMenuContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 10px;
            box-sizing: border-box;
        }
        #difficultySelection {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
            margin-top: 0;
            padding: 15px;
            border: 2px solid #ffff00;
            border-radius: 10px;
            background-color: rgba(30, 30, 0, 0.5);
            width: 100%;
            box-sizing: border-box;
        }
        #difficultySelection h3 {
            margin: 0 0 10px 0;
            color: #ffff00;
            font-size: clamp(16px, 4vw, 18px);
            text-align: center;
        }

        /* --- Buttons --- */
        button {
            font-family: 'Press Start 2P', cursive;
            background-color: #333;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 8px 15px;
            font-size: clamp(12px, 3vw, 16px);
            cursor: pointer;
            box-shadow: 0 0 8px #00ff00 inset;
            transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s;
            border-radius: 5px;
            white-space: nowrap;
            flex-grow: 0;
            flex-shrink: 1;
        }
        .difficulty-button {
            border-color: #ffff00;
            color: #ffff00;
            box-shadow: 0 0 8px #ffff00 inset;
            min-width: auto;
            text-align: center;
        }
        .difficulty-button:hover:not(:disabled),
        .difficulty-button:focus:not(:disabled) {
            box-shadow: 0 0 12px #ffff00 inset, 0 0 8px #ffff00;
            background-color: #444;
        }
        .difficulty-button.selected {
            background-color: #555500;
            box-shadow: 0 0 12px #ffff00 inset, 0 0 12px #ffff00;
            color: #fff;
        }
        #actualStartButton {
            margin-top: 20px;
            display: none;
        }
        button:hover:not(:disabled),
        button:focus:not(:disabled) {
            background-color: #444;
            outline: none;
        }
        button:not(.difficulty-button):hover:not(:disabled) {
            box-shadow: 0 0 12px #00ff00 inset, 0 0 8px #00ff00;
        }
        button:active:not(:disabled) {
            background-color: #222;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* --- Message Box --- */
        #messageBox {
            position: fixed;
            /* Adjusted top position - try 35% instead of 50% */
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%); /* Still center relative to the new top */
            background-color: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff0000;
            padding: 20px;
            text-align: center;
            color: #ff0000;
            display: none;
            z-index: 30;
            box-shadow: 0 0 20px #ff0000;
            border-radius: 10px;
            width: 85%;
            max-width: 500px;
            box-sizing: border-box;
            max-height: 80vh;
            overflow-y: auto;
        }
        #messageBox h2 {
            margin: 0 0 10px 0;
            font-size: clamp(20px, 5vw, 32px);
        }
        #messageBox p {
            margin: 5px 0 10px 0;
            font-size: clamp(12px, 3vw, 16px);
            color: #ffff00;
        }
        #messageBox p.bonus-alert {
            color: #ffaa00;
            font-weight: bold;
            display: none;
        }
        .messageBoxButtons {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        #goToStoreButton, #skipStoreButton {
            display: none;
        }

        /* --- Pause Overlay --- */
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffff00;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: clamp(30px, 10vw, 48px);
            text-shadow: 3px 3px #ff0000;
            z-index: 15;
            pointer-events: none;
        }

        /* --- Inter-Level Store Modal --- */
        #storeModal {
            position: fixed;
            /* Change top to center it more reliably */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* Or 95% in the media query */
            max-width: 600px;
            /* Reduce max-height slightly for more breathing room */
            max-height: 75vh; /* Try 75vh or even 70vh */
            background-color: rgba(0, 20, 0, 0.9);
            border: 3px solid #00ff00;
            border-radius: 15px;
            box-shadow: 0 0 25px #00ff00;
            padding: 15px; /* Or adjusted padding from media query */
            z-index: 20;
            display: none; /* Initially hidden */
            color: #00ff00;
            font-size: clamp(11px, 2.5vw, 13.5px);
            box-sizing: border-box;
            overflow-y: auto; /* Ensure this is still present */
        }
        #storeModal h2 {
            font-size: clamp(20px, 5vw, 28px);
            margin: 0 0 15px 0;
            text-align: center;
            color: #ffff00;
        }
        #storeScore {
            font-size: clamp(14px, 3.5vw, 18px);
            margin-bottom: 15px;
            text-align: center;
            color: #fff;
        }
        #storeItemsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        .storeItem {
            padding: 10px;
            background-color: rgba(0, 50, 0, 0.7);
            border-radius: 5px;
            border: 1px solid #008800;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100px;
        }
        .storeItemInfo {
            margin-bottom: 8px;
        }
        .storeItemInfo span {
            display: block;
            margin-bottom: 3px;
        }
        .itemCost {
            color: #ffff00;
        }
        .itemStock {
            color: #aaa;
            font-size: clamp(10px, 2vw, 12px);
        }
        .buyButton {
            padding: 6px 12px;
            font-size: clamp(11px, 2.5vw, 14px);
            min-width: auto;
            align-self: flex-end;
        }
        #storeContinueButton {
            display: block;
            margin: 20px auto 0 auto;
        }

        /* --- Footer --- */
        footer {
            width: 100%;
            max-width: 800px; /* Match other content width */
            margin-top: 20px; /* Space above footer */
            padding: 10px 0;
            /* text-align: center; Removed for flex */
            border-top: 1px solid #005500; /* Subtle green border */
            font-size: clamp(10px, 2.5vw, 12px); /* Smaller font size */
            /* --- ADDED FLEXBOX FOR DESKTOP --- */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping if needed */
            gap: 10px; /* Add gap between link groups */
        }
        /* General link styling for the footer */
        footer a {
            color: #00ff00; /* Green links */
            text-decoration: none;
            /* margin: 0 10px; Adjusted below for within groups */
            transition: color 0.3s, text-shadow 0.3s;
            display: inline-block; /* Ensure links behave like blocks for margin */
            vertical-align: middle; /* Align links vertically */
            line-height: 1; /* Prevent extra line height */
            margin: 0 5px; /* Spacing within a group */
        }
        footer a:hover,
        footer a:focus {
            color: #ffff00; /* Yellow hover */
            text-shadow: 0 0 5px #ffff00; /* Yellow glow */
            outline: none;
        }
        /* Style for the badge images inside the footer links */
        footer a img {
            vertical-align: middle; /* Align badges vertically with text */
            margin: 0 3px; /* Add small horizontal space around badges */
            height: 20px; /* Set a consistent height for badges */
            width: auto; /* Maintain aspect ratio */
        }
        /* Link group containers - no specific style needed by default with flex */
        footer .link-group {
             /* display: block; Removed - Flex handles layout */
             /* Add some margin between groups if flex gap isn't enough or preferred */
             /* margin: 0 10px; */
        }


        /* --- Media Queries for Smaller Screens --- */
        @media (max-width: 768px) {
             #uiContainer { gap: 8px; padding: 5px 0; }
             #controlsContainer { gap: 8px; }
             #specialWeaponsUI { gap: 10px; padding: 6px 8px; }
             #difficultySelection { gap: 8px; padding: 10px; }
             button { padding: 6px 12px; }
             #messageBox { padding: 15px; }
             #storeModal { padding: 10px; }
             #storeItemsContainer { gap: 8px; }
             footer { margin-top: 15px; gap: 8px; /* Adjust gap */ }
             footer a { margin: 0 4px; } /* Adjust link margin */
             footer a img { margin: 0 2px; height: 18px; } /* Adjust badge spacing/size */
            .storeItem {
                flex-direction: row;      /* Arrange children (info, button) horizontally */
                align-items: center;    /* Vertically center info and button in the row */
                justify-content: space-between; /* Push info left, button right */
                padding: 8px 10px;      /* Adjust padding */
                min-height: 0;          /* Remove minimum height */
                gap: 10px;              /* Add space between info and button */
            }

            .storeItemInfo {
                margin-bottom: 0;       /* Remove bottom margin */
                flex-grow: 1;           /* Allow info block to take up available space */
            }

            .storeItemInfo span {
                display: block;
                margin-bottom: 2px;     /* Slightly reduce space between info lines */
                line-height: 1.2;       /* Adjust line height */
                /* Base font size for this breakpoint (can be inherited or set here) */
                /* font-size: 11px; /* Example if needed */
            }

            .buyButton {
                align-self: center;
                flex-shrink: 0;         /* Prevent button from shrinking */
                 /* Use the general button padding defined above (6px 12px) */
                 /* Or define specific padding if needed: padding: 5px 10px; */
            }
        }

        @media (max-width: 480px) {
            body { padding: 5px; }
            h1#mainTitle { font-size: 18px; margin-bottom: 10px; }
            #uiContainer { font-size: 9px; gap: 5px; justify-content: space-between;}
            #controlsContainer { gap: 5px; }
            #specialWeaponsUI { gap: 8px; padding: 5px; }
            #difficultySelection { padding: 8px; gap: 6px; }
            #difficultySelection h3 { font-size: 14px; margin-bottom: 8px; }
            button { padding: 5px 10px; font-size: 10px; }
            .difficulty-button { font-size: 11px; }
            #messageBox { padding: 10px; width: 90%; }
             /* Slightly adjust message box position for very small screens if needed */
             /* #messageBox { top: 42%; } */
            #messageBox h2 { font-size: 18px; }
            #messageBox p { font-size: 11px; }
            .messageBoxButtons { gap: 8px; }
            #storeModal { padding: 8px; width: 95%; max-height: 70vh; }
            #storeModal h2 { font-size: 18px; }
            #storeScore { font-size: 12px; }
            #storeItemsContainer { grid-template-columns: 1fr; } /* Stack items */
            /* Overrides for store items on the smallest screens */
            .storeItem {
                 padding: 6px 8px; /* Further reduced padding */
                 gap: 8px;         /* Adjust gap if needed */
                 /* inherits flex-direction: row etc. from 768px block */
            }

            .storeItemInfo span {
                font-size: 10px;    /* Keep small font size */
                margin-bottom: 1px; /* Further tighten lines */
                line-height: 1.15;  /* Further tighten lines */
            }
            .itemStock {
                font-size: 9px;     /* Keep small font size */
            }
            .buyButton {
                padding: 4px 8px;   /* Keep specific small padding */
                font-size: 10px;    /* Keep specific small font size */
                 /* inherits flex-shrink: 0 etc. from 768px block */
            }
            .storeItemInfo span { font-size: 10px; }
            .itemStock { font-size: 9px; }
            .buyButton { padding: 4px 8px; font-size: 10px; }
            #pauseOverlay { font-size: 24px; }

            /* --- FOOTER STYLES for < 480px --- */
            footer {
                margin-top: 10px;
                font-size: 9px;
                padding: 8px 0;
                display: block; /* Override flex for stacking */
                text-align: center; /* Center the block elements */
            }
            /* Ensure each group takes its own line */
            footer .link-group {
                display: block; /* Each group is a block element */
                margin-bottom: 5px; /* Add space between the groups */
                text-align: center; /* Center the links within the group */
            }
            /* Style links within each group to be inline */
            footer .link-group a {
                display: inline-block; /* Links are inline within their group */
                margin: 2px 5px; /* Adjust spacing around links */
                vertical-align: middle; /* Keep vertical alignment consistent */
            }
            /* Adjust badge size and margin for small screens */
            footer .link-group a img {
                margin: 0 2px;
                height: 16px;
            }
            /* --- END FOOTER STYLES --- */
        }

    </style>
</head>
<body>

    <div id="startMenuContainer">
        <h1 id="mainTitle">MISSILE COMMAND</h1>
        <div id="difficultySelection">
            <h3>SELECT DIFFICULTY</h3>
            <button class="difficulty-button" data-ammo="150">Level 1 (150 Ammo)</button>
            <button class="difficulty-button" data-ammo="125">Level 2 (125 Ammo)</button>
            <button class="difficulty-button" data-ammo="100">Level 3 (100 Ammo)</button>
            <button class="difficulty-button" data-ammo="80">Level 4 (80 Ammo)</button>
            <button class="difficulty-button" data-ammo="60">Level 5 (60 Ammo)</button>
        </div>
        <button id="actualStartButton">Start Game</button>
    </div>

    <div id="uiContainer">
        <div id="score">SCORE: 0</div>
        <div id="level">LEVEL: 1</div>
        <div id="citiesLeft">CITIES: 6</div>
        <div id="bonusIndicator">BONUS FIRE +0!</div>
    </div>

    <div id="canvasContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="pauseOverlay">PAUSED</div>
    </div>

    <div id="specialWeaponsUI">
        <div class="weaponControl" id="sonicWaveControl">
            <div class="weaponIcon">🌊</div>
            <span class="weaponCount" id="sonicWaveCount">0</span>
        </div>
        <div class="weaponControl" id="bombControl">
            <div class="weaponIcon">💣</div>
            <span class="weaponCount" id="bombCount">0</span>
        </div>
    </div>

    <div id="controlsContainer">
        <button id="restartButton" style="display: none;">Restart Game</button>
        <button id="pauseButton" style="display: none;">Pause</button>
        <button id="screenshotButton" style="display: none;">Save Screenshot</button>
    </div>

    <div id="messageBox">
        <h2 id="messageTitle"></h2>
        <p id="messageText"></p>
        <p id="messageSubText"></p>
        <p id="messageBonusText" class="bonus-alert"></p>
        <div class="messageBoxButtons">
            <button id="goToStoreButton">Go to Store</button>
            <button id="skipStoreButton">Next Level</button>
        </div>
    </div>

    <div id="storeModal">
        <h2>Inter-Level Store</h2>
        <div id="storeScore">Current Score: $0</div>
        <div id="storeItemsContainer">
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Sonic Wave</span>
                    <span class="itemCost">Cost: $1000</span>
                    <span class="itemStock" id="stockSonicWave">Stock: 6</span>
                </div>
                <button class="buyButton" id="buySonicWaveButton">BUY</button>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Mega Bomb</span>
                    <span class="itemCost">Cost: $500</span>
                    <span class="itemStock" id="stockBomb">Stock: 12</span>
                </div>
                <button class="buyButton" id="buyBombButton">BUY</button>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Satellite Base (Max 3)</span>
                    <span class="itemCost">Cost: $4000</span>
                    <span class="itemStock" id="stockSatellite">Stock: 6</span>
                </div>
                <button class="buyButton" id="buySatelliteButton">BUY</button>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Satellite Shield</span>
                    <span class="itemCost">Cost: $250</span>
                    <span class="itemStock" id="stockSatShield">Stock: 100</span>
                </div>
                <button class="buyButton" id="buySatShieldButton">BUY</button>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Replacement Base</span>
                    <span class="itemCost">Cost: $1000</span>
                    <span class="itemStock" id="stockBase">Stock: 6</span>
                </div>
                <button class="buyButton" id="buyBaseButton">BUY</button>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Replacement City</span>
                    <span class="itemCost">Cost: $2000</span>
                    <span class="itemStock" id="stockCity">Stock: 6</span>
                </div>
                <button class="buyButton" id="buyCityButton">BUY</button>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Base Shield</span>
                    <span class="itemCost">Cost: $250</span>
                    <span class="itemStock" id="stockShield">Stock: 100</span>
                </div>
                <button class="buyButton" id="buyShieldButton">BUY</button>
            </div>
        </div>
        <button id="storeContinueButton">Continue to Next Level</button>
    </div>

    <footer>
        <div class="link-group social-links">
            <a href="https://x.com/George_SLiu" target="_blank" rel="noopener noreferrer">Twitter</a>
            <a href="https://www.threads.net/@george_sl_liu" target="_blank" rel="noopener noreferrer">Threads</a>
            <a href="https://bsky.app/profile/georgesl.bsky.social" target="_blank" rel="noopener noreferrer">BlueSky</a>
        </div>
        <div class="link-group github-links">
            <a href="https://github.com/sponsors/centminmod" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/sponsors/centminmod" alt="GitHub Sponsors" loading="lazy">
            </a>
            <a href="https://github.com/centminmod/atari-missile-command/stargazers" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/stars/centminmod/atari-missile-command.svg?style=flat-square" alt="Centmin Mod GitHub stars" loading="lazy">
            </a>
            <a href="https://github.com/centminmod/atari-missile-command/network" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/forks/centminmod/atari-missile-command.svg?style=flat-square" alt="Centmin Mod GitHub forks" loading="lazy">
            </a>
            <a href="https://github.com/centminmod/atari-missile-command/issues" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/issues/centminmod/atari-missile-command.svg?style=flat-square" alt="Centmin Mod GitHub issues" loading="lazy">
            </a>
        </div>
    </footer>

    <script>
        // --- Canvas, Context, UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const citiesLeftDisplay = document.getElementById('citiesLeft');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const screenshotButton = document.getElementById('screenshotButton');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const messageSubText = document.getElementById('messageSubText');
        const messageBonusText = document.getElementById('messageBonusText');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const uiContainer = document.getElementById('uiContainer');
        const controlsContainer = document.getElementById('controlsContainer');
        const difficultySelectionDiv = document.getElementById('difficultySelection');
        const startMenuContainer = document.getElementById('startMenuContainer');
        const actualStartButton = document.getElementById('actualStartButton');
        const bonusIndicator = document.getElementById('bonusIndicator');
        const goToStoreButton = document.getElementById('goToStoreButton');
        const skipStoreButton = document.getElementById('skipStoreButton');
        const storeModal = document.getElementById('storeModal');
        const storeScoreDisplay = document.getElementById('storeScore');
        const stockSatelliteDisplay = document.getElementById('stockSatellite');
        const stockBaseDisplay = document.getElementById('stockBase');
        const stockCityDisplay = document.getElementById('stockCity');
        const stockShieldDisplay = document.getElementById('stockShield');
        const stockSatShieldDisplay = document.getElementById('stockSatShield');
        const stockSonicWaveDisplay = document.getElementById('stockSonicWave');
        const stockBombDisplay = document.getElementById('stockBomb');
        const buySatelliteButton = document.getElementById('buySatelliteButton');
        const buyBaseButton = document.getElementById('buyBaseButton');
        const buyCityButton = document.getElementById('buyCityButton');
        const buyShieldButton = document.getElementById('buyShieldButton');
        const buySatShieldButton = document.getElementById('buySatShieldButton');
        const buySonicWaveButton = document.getElementById('buySonicWaveButton');
        const buyBombButton = document.getElementById('buyBombButton');
        const storeContinueButton = document.getElementById('storeContinueButton');
        const specialWeaponsUIDiv = document.getElementById('specialWeaponsUI');
        const sonicWaveControl = document.getElementById('sonicWaveControl');
        const sonicWaveCountDisplay = document.getElementById('sonicWaveCount');
        const bombControl = document.getElementById('bombControl');
        const bombCountDisplay = document.getElementById('bombCount');
        const canvasContainer = document.getElementById('canvasContainer'); // Get the container

        // --- Game Constants & State Variables ---
        // ** Important: Game logic still uses the canvas's internal 800x600 coordinate system.**
        // The CSS handles the visual scaling. The JS click handling already scales coordinates.
        const INTERNAL_WIDTH = 800;
        const INTERNAL_HEIGHT = 600;
        const GROUND_HEIGHT_RATIO = 50 / INTERNAL_HEIGHT; // Ratio for ground height
        const BASE_WIDTH_RATIO = 40 / INTERNAL_WIDTH;
        const BASE_HEIGHT_RATIO = 25 / INTERNAL_HEIGHT;
        const CITY_WIDTH_RATIO = 50 / INTERNAL_WIDTH;
        const CITY_HEIGHT_RATIO = 30 / INTERNAL_HEIGHT;
        const SATELLITE_WIDTH_RATIO = 35 / INTERNAL_WIDTH;
        const SATELLITE_HEIGHT_RATIO = 25 / INTERNAL_HEIGHT;
        const SATELLITE_Y_POS_RATIO = (INTERNAL_HEIGHT * 0.4) / INTERNAL_HEIGHT; // Y position as ratio

        // Game speeds and sizes (can remain mostly pixel-based for internal calculations)
        const MISSILE_SPEED_PLAYER = 5;
        const MISSILE_SPEED_ENEMY_BASE = 0.5;
        const EXPLOSION_RADIUS_START = 10;
        const EXPLOSION_RADIUS_MAX = 50;
        const EXPLOSION_DURATION = 50;
        const POINTS_PER_MISSILE = 25;
        const POINTS_PER_CITY = 100;
        const POINTS_PER_AMMO = 5;
        const MISSILES_PER_LEVEL_BASE = 8;
        let selectedDifficultyAmmo = 60;
        const BONUS_FIRE_SPREAD = 8;
        const COST_SATELLITE = 4000;
        const COST_BASE = 1000;
        const COST_CITY = 2000;
        const COST_SHIELD = 250;
        const COST_SAT_SHIELD = 250;
        const COST_SONIC_WAVE = 1000;
        const COST_BOMB = 500;
        const MAX_STOCK = 20;
        const MAX_SHIELD_STOCK = 100;
        const MAX_SAT_SHIELD_STOCK = 100;
        const MAX_SONIC_WAVE_STOCK = 20;
        const MAX_BOMB_STOCK = 20;
        const MAX_ACTIVE_SATELLITES = 3;
        const SHIELD_STRENGTH_START = 100;
        const SHIELD_DAMAGE_PER_HIT = 10;
        const SHIELD_COLOR_FULL = 'rgba(0, 150, 255, 0.6)';
        const SHIELD_COLOR_75 = 'rgba(0, 255, 150, 0.6)';
        const SHIELD_COLOR_50 = 'rgba(255, 255, 0, 0.6)';
        const SHIELD_COLOR_25 = 'rgba(255, 100, 0, 0.6)';
        const SHIELD_FLASH_COLOR = 'rgba(255, 255, 255, 0.8)';
        const SHIELD_FLASH_DURATION = 5;
        const BOMB_EXPLOSION_RADIUS_MULTIPLIER = 6;
        const BOMB_EXPLOSION_DURATION_MULTIPLIER = 1.5;
        const SONIC_WAVE_SPEED = 4;
        const SONIC_WAVE_HEIGHT = 10; // Keep as pixels for now
        const SONIC_WAVE_COLOR = 'rgba(200, 0, 255, 0.5)';

        // Game State
        let score = 0;
        let level = 1;
        let cities = [];
        let bases = [];
        let incomingMissiles = [];
        let playerMissiles = [];
        let explosions = [];
        let isGameOver = true;
        let gameLoopId = null;
        let missilesToSpawn = 0;
        let enemyMissileSpeed = MISSILE_SPEED_ENEMY_BASE;
        let transitioningLevel = false;
        let isPaused = false;
        let gameHasStarted = false;
        let difficultySelected = false;
        let bonusMissileCount = 0;
        let storeStockSatellite = MAX_STOCK;
        let storeStockBase = MAX_STOCK;
        let storeStockCity = MAX_STOCK;
        let storeStockShield = MAX_SHIELD_STOCK;
        let storeStockSatShield = MAX_SAT_SHIELD_STOCK;
        let storeStockSonicWave = MAX_SONIC_WAVE_STOCK;
        let storeStockBomb = MAX_BOMB_STOCK;
        let satelliteBases = [];
        let baseShields = [null, null, null];
        let inventorySonicWave = 0;
        let inventoryBomb = 0;
        let isBombArmed = false;
        let activeSonicWave = null;

        // --- Utility Functions ---
        // No changes needed here - uses internal coordinates
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function getRandomTarget() {
            const aliveCities = cities.filter(c => c.alive);
            const aliveBases = bases.filter(b => b.alive);
            const aliveSatellites = satelliteBases.filter(s => s.alive);
            let possibleTargets = [...aliveCities, ...aliveBases, ...aliveSatellites];
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            if (possibleTargets.length === 0) {
                return { x: canvas.width / 2, y: groundY };
            }
            const target = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
            return { x: target.x + (target.width / 2), y: target.y };
        }

        // --- Game Object Factories ---
        // Modified to use ratios for positioning and sizing relative to internal canvas dimensions
        function createCity(xRatio) {
            const cityWidth = canvas.width * CITY_WIDTH_RATIO;
            const cityHeight = canvas.height * CITY_HEIGHT_RATIO;
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            const cityX = xRatio * canvas.width;
            const cityY = groundY - cityHeight;

            const buildings = [];
            const numBuildings = 3 + Math.floor(Math.random() * 3);
            let currentX = cityX;
            const totalBuildingWidth = cityWidth * 0.9;
            const baseBuildingWidth = totalBuildingWidth / numBuildings;
            for (let i = 0; i < numBuildings; i++) {
                const buildingHeight = (cityHeight * 0.6) + (Math.random() * cityHeight * 0.4);
                const buildingWidth = baseBuildingWidth * (0.8 + Math.random() * 0.4);
                const gap = (baseBuildingWidth - buildingWidth) / 2;
                buildings.push({
                    x: currentX + gap,
                    y: groundY - buildingHeight,
                    w: buildingWidth,
                    h: buildingHeight,
                    color: `hsl(180, 100%, ${35 + Math.random() * 15}%)`
                });
                currentX += baseBuildingWidth;
            }
            return {
                x: cityX, y: cityY, width: cityWidth, height: cityHeight, alive: true, buildings: buildings,
                draw() {
                    if (!this.alive) return;
                    this.buildings.forEach(b => {
                        ctx.fillStyle = b.color;
                        ctx.fillRect(b.x, b.y, b.w, b.h);
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        const windowSize = Math.min(b.w, b.h) * 0.15;
                        const cols = Math.floor(b.w / (windowSize * 2.5));
                        const rows = Math.floor(b.h / (windowSize * 3));
                        if (cols > 0 && rows > 0) {
                            const xSpacing = b.w / cols; const ySpacing = b.h / rows;
                            for (let r = 0; r < rows; r++) {
                                for (let c = 0; c < cols; c++) {
                                    ctx.fillRect(b.x + xSpacing * (c + 0.5) - windowSize / 2, b.y + ySpacing * (r + 0.5) - windowSize / 2, windowSize, windowSize);
                                }
                            }
                        }
                        ctx.strokeStyle = '#006666'; ctx.lineWidth = 1; ctx.strokeRect(b.x, b.y, b.w, b.h);
                    });
                }
            };
        }
        function createBase(xRatio) {
            const baseWidth = canvas.width * BASE_WIDTH_RATIO;
            const baseHeight = canvas.height * BASE_HEIGHT_RATIO;
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            const baseX = (xRatio * canvas.width) - (baseWidth / 2); // Center the base on the ratio
            const baseY = groundY - baseHeight;
            return {
                x: baseX, y: baseY, width: baseWidth, height: baseHeight,
                color: '#dddd00', outlineColor: '#aaaa00', launcherColor: '#999999',
                alive: true, ammo: selectedDifficultyAmmo, isSatellite: false,
                draw() {
                    if (!this.alive) return;
                    ctx.fillStyle = this.color; ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height); ctx.lineTo(this.x + this.width * 0.2, this.y);
                    ctx.lineTo(this.x + this.width * 0.8, this.y); ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = this.outlineColor; ctx.lineWidth = 2; ctx.stroke();
                    const launcherWidth = this.width * 0.15; const launcherHeight = this.height * 0.4;
                    ctx.fillStyle = this.launcherColor;
                    ctx.fillRect(this.x + this.width / 2 - launcherWidth / 2, this.y - launcherHeight, launcherWidth, launcherHeight);
                    ctx.fillStyle = '#666666'; ctx.fillRect(this.x + this.width / 2 - launcherWidth / 2, this.y - launcherHeight * 0.3, launcherWidth, 2);
                    ctx.fillStyle = '#000';
                    // Adjust font size slightly based on base size for readability
                    const fontSize = Math.max(8, Math.min(12, Math.floor(this.width * 0.3)));
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(this.ammo, this.x + this.width / 2, this.y + this.height / 2);
                }
            };
        }
        function createSatelliteBase(xRatio, yRatio) {
            const satWidth = canvas.width * SATELLITE_WIDTH_RATIO;
            const satHeight = canvas.height * SATELLITE_HEIGHT_RATIO;
            const satX = (xRatio * canvas.width) - (satWidth / 2); // Center satellite
            const satY = yRatio * canvas.height;
            return {
                x: satX, y: satY, width: satWidth, height: satHeight,
                bodyColor: '#b0b0b0', panelColor: '#3333cc', panelHighlight: '#6666ff',
                outlineColor: '#777777', antennaColor: '#dddddd', lightColor: '#ff0000',
                alive: true, ammo: selectedDifficultyAmmo, isSatellite: true, shield: null,
                draw() {
                    if (!this.alive) return;
                    const bodyW = this.width * 0.5; const bodyH = this.height;
                    const bodyX = this.x + (this.width - bodyW) / 2;
                    const panelW = this.width * 0.25; const panelH = this.height * 0.8;
                    const panelY = this.y + (bodyH - panelH) / 2;
                    ctx.fillStyle = this.panelColor; ctx.fillRect(this.x, panelY, panelW, panelH);
                    ctx.fillRect(this.x + this.width - panelW, panelY, panelW, panelH);
                    ctx.strokeStyle = this.panelHighlight; ctx.lineWidth = 1; ctx.beginPath();
                    ctx.moveTo(this.x + panelW / 2, panelY); ctx.lineTo(this.x + panelW / 2, panelY + panelH);
                    ctx.moveTo(this.x + this.width - panelW / 2, panelY); ctx.lineTo(this.x + this.width - panelW / 2, panelY + panelH);
                    ctx.moveTo(this.x, panelY + panelH / 3); ctx.lineTo(this.x + panelW, panelY + panelH / 3);
                    ctx.moveTo(this.x, panelY + panelH * 2/3); ctx.lineTo(this.x + panelW, panelY + panelH * 2/3);
                    ctx.moveTo(this.x + this.width - panelW, panelY + panelH / 3); ctx.lineTo(this.x + this.width, panelY + panelH / 3);
                    ctx.moveTo(this.x + this.width - panelW, panelY + panelH * 2/3); ctx.lineTo(this.x + this.width, panelY + panelH * 2/3);
                    ctx.stroke();
                    ctx.fillStyle = this.bodyColor; ctx.beginPath();
                    ctx.moveTo(bodyX, this.y + bodyH * 0.2); ctx.lineTo(bodyX + bodyW * 0.1, this.y); ctx.lineTo(bodyX + bodyW * 0.9, this.y);
                    ctx.lineTo(bodyX + bodyW, this.y + bodyH * 0.2); ctx.lineTo(bodyX + bodyW, this.y + bodyH * 0.8);
                    ctx.lineTo(bodyX + bodyW * 0.9, this.y + bodyH); ctx.lineTo(bodyX + bodyW * 0.1, this.y + bodyH);
                    ctx.lineTo(bodyX, this.y + bodyH * 0.8); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = this.outlineColor; ctx.lineWidth = 1; ctx.stroke();
                    const dishRadius = bodyW * 0.3; const dishY = this.y - dishRadius * 0.6;
                    ctx.strokeStyle = this.antennaColor; ctx.lineWidth = 2; ctx.beginPath();
                    ctx.arc(bodyX + bodyW / 2, dishY, dishRadius, Math.PI * 1.1, Math.PI * 1.9); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(bodyX + bodyW / 2, this.y); ctx.lineTo(bodyX + bodyW / 2, dishY); ctx.stroke();
                    const nozzleWidth = bodyW * 0.2; const nozzleHeight = bodyH * 0.25;
                    ctx.fillStyle = this.outlineColor; ctx.fillRect(bodyX + (bodyW / 2) - (nozzleWidth / 2), this.y + bodyH, nozzleWidth, nozzleHeight);
                    ctx.fillStyle = this.lightColor; if (Math.floor(Date.now() / 500) % 2 === 0) { ctx.beginPath(); ctx.arc(bodyX + bodyW / 2, this.y + bodyH / 2, 2, 0, Math.PI * 2); ctx.fill(); }
                    ctx.fillStyle = '#ffff00';
                    const fontSize = Math.max(7, Math.min(10, Math.floor(this.width * 0.25)));
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                    ctx.fillText(this.ammo, this.x + this.width / 2, this.y + bodyH + nozzleHeight + 3);
                }
            };
        }
        function createIncomingMissile() {
            const startX = Math.random() * canvas.width;
            const target = getRandomTarget();
            const angle = Math.atan2(target.y - 0, target.x - startX);
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            return {
                x: startX, y: 0, targetX: target.x, targetY: target.y,
                dx: Math.cos(angle) * enemyMissileSpeed, dy: Math.sin(angle) * enemyMissileSpeed,
                color: '#ff0000', trailColor: 'rgba(255, 100, 100, 0.5)', alive: true, trail: [{x: startX, y: 0}],
                update() {
                    if (!this.alive) return; this.x += this.dx; this.y += this.dy;
                    this.trail.push({x: this.x, y: this.y}); if (this.trail.length > 15) { this.trail.shift(); }
                    if (this.y >= this.targetY || this.y >= groundY) {
                        this.alive = false;
                        const impactY = Math.min(this.targetY, groundY);
                        createExplosion(this.x, impactY, EXPLOSION_RADIUS_MAX / 2, this.color);
                        checkObjectImpact(this.x, impactY);
                    }
                },
                draw() { /* Draw logic remains the same */
                    if (!this.alive) return; ctx.strokeStyle = this.trailColor; ctx.lineWidth = 2; ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke();
                    ctx.fillStyle = this.color; ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                }
            };
        }
        function createPlayerMissile(startX, startY, targetX, targetY) {
            const angle = Math.atan2(targetY - startY, targetX - startX);
            return {
                x: startX, y: startY, targetX: targetX, targetY: targetY,
                dx: Math.cos(angle) * MISSILE_SPEED_PLAYER, dy: Math.sin(angle) * MISSILE_SPEED_PLAYER,
                color: '#00ff00', trailColor: 'rgba(100, 255, 100, 0.5)', alive: true, trail: [{x: startX, y: startY}],
                update() { /* Update logic remains the same */
                    if (!this.alive) return; this.x += this.dx; this.y += this.dy;
                    this.trail.push({x: this.x, y: this.y}); if (this.trail.length > 10) { this.trail.shift(); }
                    const distToTarget = distance(this.x, this.y, this.targetX, this.targetY);
                    const distTraveled = distance(startX, startY, this.x, this.y);
                    const totalDist = distance(startX, startY, this.targetX, this.targetY);
                    if (distTraveled >= totalDist || distToTarget < MISSILE_SPEED_PLAYER) {
                        this.alive = false; createExplosion(this.targetX, this.targetY, EXPLOSION_RADIUS_START, this.color);
                    }
                },
                draw() { /* Draw logic remains the same */
                    if (!this.alive) return; ctx.strokeStyle = this.trailColor; ctx.lineWidth = 2; ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke();
                    ctx.fillStyle = this.color; ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
                }
            };
        }
        function createExplosion(x, y, startRadius, color, maxRadius = EXPLOSION_RADIUS_MAX, duration = EXPLOSION_DURATION) {
            // Explosion logic remains the same - uses internal coordinates
            if (typeof color !== 'string' || !color.startsWith('#')) { color = '#888888'; }
            explosions.push({
                x: x, y: y, radius: startRadius, maxRadius: maxRadius, duration: duration, currentFrame: 0, color: color, alive: true,
                update() { /* Update logic remains the same */
                    if (!this.alive) return; this.currentFrame++;
                    const expansionPhase = this.duration * 0.6;
                    if (this.currentFrame <= expansionPhase) { this.radius = startRadius + (this.maxRadius - startRadius) * (this.currentFrame / expansionPhase); }
                    else { this.radius = this.maxRadius - (this.maxRadius * ((this.currentFrame - expansionPhase) / (this.duration - expansionPhase))); }
                    this.radius = Math.max(0, this.radius);
                    if (this.currentFrame >= this.duration) { this.alive = false; }
                    if(this.currentFrame < expansionPhase) { checkExplosionCollisions(this); }
                },
                draw() { /* Draw logic remains the same */
                    if (!this.alive) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    const intensity = Math.sin((this.currentFrame / this.duration) * Math.PI);
                    const r = parseInt(this.color.slice(1, 3), 16); const g = parseInt(this.color.slice(3, 5), 16); const b = parseInt(this.color.slice(5, 7), 16);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + intensity * 0.6})`; ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.3 * intensity, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.8})`; ctx.fill();
                }
            });
        }

        // --- Collision Detection ---
        // Uses internal coordinates - no changes needed
        function checkExplosionCollisions(explosion) {
            incomingMissiles.forEach(missile => {
                if (missile.alive) {
                    const dist = distance(explosion.x, explosion.y, missile.x, missile.y);
                    if (dist < explosion.radius) {
                        missile.alive = false; score += POINTS_PER_MISSILE;
                        createExplosion(missile.x, missile.y, EXPLOSION_RADIUS_START, missile.color);
                    }
                }
            });
        }
        function checkObjectImpact(impactX, impactY) {
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            const cityHeight = canvas.height * CITY_HEIGHT_RATIO;
            const baseHeight = canvas.height * BASE_HEIGHT_RATIO;

            // Check Base Shields
            for (let i = 0; i < baseShields.length; i++) {
                const shield = baseShields[i];
                if (shield && shield.alive) {
                    const base = bases[i];
                    const shieldCenterX = base.x + base.width / 2;
                    // MODIFIED: Increase original radius calculation by 80% (multiply by 1.80) - per user diff
                    const shieldRadius = 1.80 * ((base.width / 2) + (canvas.width * CITY_WIDTH_RATIO / 2) + 5);

                    // --- Shield Shape & Position Variables ---
                    // MODIFIED: Changed -5 to -15 to move shield higher
                    const shieldBottomEdgeY = base.y - 15; // Y coordinate of the shield's left/right ends
                    const shieldApexY = shieldBottomEdgeY - shieldRadius * 0.3; // Y coordinate of the shield's highest point (apex)
                    const startX = shieldCenterX - shieldRadius;
                    const endX = shieldCenterX + shieldRadius;
                    const shieldWidth = endX - startX; // Should be 2 * shieldRadius
                    // --- End Shield Shape & Position Variables ---


                    // --- COLLISION CHECK ---
                    // 1. Quick check: Is the impact within the horizontal span of the shield?
                    if (impactX >= startX && impactX <= endX) {
                        // 2. Calculate the expected Y position on the shield curve at the impactX
                        let y_on_curve;
                        if (shieldWidth > 0) {
                            const t = (impactX - startX) / shieldWidth; // Parameter t (0 to 1) along the curve width
                            // Quadratic Bezier curve formula: y(t) = (1-t)^2*P0y + 2*(1-t)*t*P1y + t^2*P2y
                            // P0y = shieldBottomEdgeY (start Y)
                            // P1y = shieldApexY (control point Y)
                            // P2y = shieldBottomEdgeY (end Y)
                            const one_minus_t = 1 - t;
                            y_on_curve = (one_minus_t * one_minus_t * shieldBottomEdgeY) +
                                         (2 * one_minus_t * t * shieldApexY) +
                                         (t * t * shieldBottomEdgeY);
                        } else {
                            // Avoid division by zero if shieldWidth is somehow zero
                            y_on_curve = shieldBottomEdgeY;
                        }

                        // 3. CORRECTED CHECK: Check if the impact Y is AT or BELOW the calculated curve position.
                        //    (Since Y increases downwards, missile hits when impactY >= y_on_curve)
                        if (impactY >= y_on_curve) {
                            // Collision detected!
                            shield.strength -= SHIELD_DAMAGE_PER_HIT;
                            shield.flashTimer = SHIELD_FLASH_DURATION;
                            if (shield.strength <= 0) {
                                shield.alive = false;
                                createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 1.5, '#ffffff');
                            } else {
                                createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 0.5, SHIELD_FLASH_COLOR);
                            }
                            return; // Impact handled by shield, stop checking other objects
                        }
                    }
                    // --- END COLLISION CHECK ---
                }
            }
            // Check Satellite Shields
            for (let i = 0; i < satelliteBases.length; i++) {
                const sat = satelliteBases[i];
                if (sat.alive && sat.shield && sat.shield.alive) {
                    const shieldCenterX = sat.x + sat.width / 2; const shieldCenterY = sat.y + sat.height / 2;
                    const shieldRadiusX = sat.width * 0.6 + 4; const shieldRadiusY = sat.height * 0.8 + 4;
                    const dx = impactX - shieldCenterX; const dy = impactY - shieldCenterY;
                    if (((dx * dx) / (shieldRadiusX * shieldRadiusX)) + ((dy * dy) / (shieldRadiusY * shieldRadiusY)) <= 1) {
                        sat.shield.strength -= SHIELD_DAMAGE_PER_HIT; sat.shield.flashTimer = SHIELD_FLASH_DURATION;
                        if (sat.shield.strength <= 0) { sat.shield.alive = false; createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 1.2, '#eeeeee'); }
                        else { createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 0.5, SHIELD_FLASH_COLOR); }
                        return;
                    }
                }
            }
            // Check Satellites
            satelliteBases.forEach(sat => {
                if (sat.alive && impactX >= sat.x && impactX <= sat.x + sat.width && impactY >= sat.y && impactY <= sat.y + sat.height) {
                    sat.alive = false; createExplosion(impactX, impactY, EXPLOSION_RADIUS_START, sat.outlineColor);
                }
            });
            // Check Cities
            if (impactY >= groundY - cityHeight) {
                cities.forEach(city => {
                    if (city.alive && impactX >= city.x && impactX <= city.x + city.width) {
                        if (impactY < groundY) { city.alive = false; }
                    }
                });
            }
            // Check Bases
            if (impactY >= groundY - baseHeight) {
                bases.forEach(base => {
                    if (base.alive && impactX >= base.x && impactX <= base.x + base.width) {
                         if (impactY < groundY) { base.alive = false; }
                    }
                });
            }
        }

        // --- Game Flow ---
        // Most game flow logic remains the same, but object creation uses ratios
        function initLevel() {
            incomingMissiles = []; playerMissiles = []; explosions = []; activeSonicWave = null;
            bases.forEach(b => { if (b.alive) b.ammo = selectedDifficultyAmmo; });
            satelliteBases.forEach(s => { if (s.alive) s.ammo = selectedDifficultyAmmo; });
            missilesToSpawn = MISSILES_PER_LEVEL_BASE + (level - 1) * 4;
            enemyMissileSpeed = MISSILE_SPEED_ENEMY_BASE + (level - 1) * 0.15;
            enemyMissileSpeed = Math.min(enemyMissileSpeed, 3.0);
            updateUI(); updateSpecialWeaponsUI();
        }
        function startGame() {
            if (!difficultySelected) { console.warn("Difficulty not selected!"); return; }
            score = 0; level = 1; isGameOver = false; isPaused = false; transitioningLevel = false; gameHasStarted = true; bonusMissileCount = 0;
            storeStockSatellite = MAX_STOCK; storeStockBase = MAX_STOCK; storeStockCity = MAX_STOCK; storeStockShield = MAX_SHIELD_STOCK; storeStockSatShield = MAX_SAT_SHIELD_STOCK; storeStockSonicWave = MAX_SONIC_WAVE_STOCK; storeStockBomb = MAX_BOMB_STOCK;
            inventorySonicWave = 0; inventoryBomb = 0; isBombArmed = false; activeSonicWave = null;
            satelliteBases = []; baseShields = [null, null, null];

            // --- UI Setup ---
            startMenuContainer.style.display = 'none';
            canvasContainer.style.display = 'block'; // Show canvas container
            canvas.style.display = 'block'; // Show canvas itself
            uiContainer.style.display = 'flex';
            controlsContainer.style.display = 'flex';
            specialWeaponsUIDiv.style.display = 'flex';
            screenshotButton.style.display = 'inline-block';
            hideMessage();
            pauseOverlay.style.display = 'none';
            canvas.style.cursor = 'crosshair';

            // --- Initialize Game Objects (using ratios) ---
            cities = [];
            const cityWidth = canvas.width * CITY_WIDTH_RATIO;
            // Calculate spacing based on internal width and city width
            const citySpacingRatio = (INTERNAL_WIDTH - 6 * (INTERNAL_WIDTH * CITY_WIDTH_RATIO)) / (7 * INTERNAL_WIDTH);
            const cityWidthRatio = CITY_WIDTH_RATIO;
            // Place cities using ratios
            for (let i = 0; i < 3; i++) cities.push(createCity(citySpacingRatio * (i + 1) + cityWidthRatio * i));
            for (let i = 0; i < 3; i++) cities.push(createCity(citySpacingRatio * (i + 4) + cityWidthRatio * (i + 3)));
            cities.forEach(c => c.alive = true);

            bases = [];
            const basePositionsRatios = [0.15, 0.5, 0.85]; // Ratios for base center positions
            bases.push(createBase(basePositionsRatios[0]));
            bases.push(createBase(basePositionsRatios[1]));
            bases.push(createBase(basePositionsRatios[2]));
            bases.forEach(b => b.alive = true);

            initLevel();
            restartButton.style.display = 'inline-block';
            pauseButton.style.display = 'inline-block'; pauseButton.textContent = 'Pause'; pauseButton.disabled = false;

            if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
            gameLoop();
        }
        function nextLevel() {
            level++;
            let bonusEarned = calculateBonus();
            score += bonusEarned;
            updateUI(); // Update score display immediately

            const citiesSurvived = cities.filter(c => c.alive).length;
            const citiesLost = 6 - citiesSurvived;
            let bonusChangeMsg = "";
            if (citiesLost > 0) {
                const lostBonus = Math.min(bonusMissileCount, citiesLost);
                if (lostBonus > 0) { bonusChangeMsg = `Lost ${lostBonus} bonus missile${lostBonus > 1 ? 's' : ''}!`; bonusMissileCount -= lostBonus; }
            } else { bonusMissileCount++; bonusChangeMsg = `PERFECT! +1 Bonus Missile!`; }
            bonusMissileCount = Math.max(0, bonusMissileCount);
            if (bonusMissileCount > 0) { bonusChangeMsg += ` (Total +${bonusMissileCount} active next level)`; }
            else if (bonusChangeMsg !== "" && citiesLost > 0) { bonusChangeMsg += ` (Bonus Fire deactivated)`; }
            else if (bonusChangeMsg === "" && citiesLost > 0){ bonusChangeMsg = ""; }

            isBombArmed = false; canvas.style.cursor = 'crosshair'; bombControl.classList.remove('armed');

            showMessage(`LEVEL ${level - 1} CLEARED`, `Score Bonus: $${bonusEarned}`, "", bonusChangeMsg);
            goToStoreButton.style.display = 'inline-block';
            skipStoreButton.style.display = 'inline-block';
            pauseButton.disabled = true;
        }
        function proceedToNextLevel() {
            storeModal.style.display = 'none'; hideMessage();
            initLevel(); transitioningLevel = false; pauseButton.disabled = false;
            if (!isPaused && !gameLoopId) { gameLoop(); }
        }
        function calculateBonus() { /* Calculation logic remains the same */
            let bonus = 0;
            cities.forEach(city => { if (city.alive) bonus += POINTS_PER_CITY; });
            bases.forEach(base => { if (base.alive) bonus += base.ammo * POINTS_PER_AMMO; });
            satelliteBases.forEach(sat => { if (sat.alive) bonus += sat.ammo * POINTS_PER_AMMO; });
            return bonus;
        }
        function checkLevelEnd() { /* Logic remains the same */
            if (transitioningLevel || isGameOver || isPaused) return;
            if (missilesToSpawn <= 0 && incomingMissiles.every(m => !m.alive) && explosions.every(e => !e.alive) && !activeSonicWave) {
                transitioningLevel = true; nextLevel();
            }
        }
        function checkGameOverConditions() { /* Logic remains the same */
            if (isGameOver || !gameHasStarted) return;
            const basesRemaining = bases.filter(b => b.alive).length;
            const citiesRemaining = cities.filter(c => c.alive).length;
            if (basesRemaining === 0 || citiesRemaining === 0) { gameOver(); }
        }
        function gameOver() { /* Logic remains the same */
            if (isGameOver) return; isGameOver = true; gameHasStarted = false; transitioningLevel = false; isPaused = false; bonusMissileCount = 0;
            baseShields = [null, null, null]; satelliteBases = []; isBombArmed = false; activeSonicWave = null; canvas.style.cursor = 'crosshair';
            const basesRemaining = bases.filter(b => b.alive).length; const citiesRemaining = cities.filter(c => c.alive).length;
            let reason = "";
            if (basesRemaining === 0 && citiesRemaining === 0) { reason = "All bases and cities destroyed!"; }
            else if (basesRemaining === 0) { reason = "All bases destroyed!"; }
            else if (citiesRemaining === 0) { reason = "All cities destroyed!"; }
            showMessage("GAME OVER", `Final Score: $${score}`, `${reason} Level: ${level}`);
            restartButton.style.display = 'inline-block'; pauseButton.style.display = 'inline-block';
            pauseButton.textContent = 'Pause'; pauseButton.disabled = true; pauseOverlay.style.display = 'none';
            bonusIndicator.style.display = 'none'; storeModal.style.display = 'none'; specialWeaponsUIDiv.style.display = 'none';
        }

        // --- Pause/Resume Logic ---
        // No changes needed
        function pauseGame() {
            if (isGameOver || transitioningLevel || !gameHasStarted || storeModal.style.display === 'block' || messageBox.style.display === 'block') return;
            isPaused = true; pauseOverlay.style.display = 'flex'; pauseButton.textContent = 'Resume';
            if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
        }
        function resumeGame() {
            if (isGameOver || transitioningLevel || !isPaused) return;
            isPaused = false; pauseOverlay.style.display = 'none'; pauseButton.textContent = 'Pause';
            if (!gameLoopId) { gameLoop(); }
        }
        function togglePause() {
            if (isPaused) { resumeGame(); } else { pauseGame(); }
            isBombArmed = false; canvas.style.cursor = 'crosshair'; bombControl.classList.remove('armed'); updateSpecialWeaponsUI();
        }

        // --- Screenshot Logic ---
        // No changes needed
        async function saveScreenshot() {
            const originalText = screenshotButton.textContent; screenshotButton.textContent = 'Saving...'; screenshotButton.disabled = true;
            try {
                if (!navigator.clipboard || !navigator.clipboard.write) { throw new Error('Clipboard API not supported or requires secure context (HTTPS/localhost).'); }
                canvas.toBlob(async (blob) => {
                    if (!blob) { throw new Error('Canvas could not be converted to Blob.'); }
                    try {
                        const item = new ClipboardItem({ 'image/png': blob }); await navigator.clipboard.write([item]);
                        screenshotButton.textContent = 'Copied!'; console.log('Screenshot copied to clipboard.');
                    } catch (err) {
                        console.error('Failed to copy screenshot:', err); screenshotButton.textContent = 'Copy Failed!';
                        // Use a simple alert for broader compatibility, though less ideal UI
                        alert(`Failed to copy to clipboard:\n${err.message}\nEnsure secure context (HTTPS/localhost) and grant permission.`);
                    } finally { setTimeout(() => { screenshotButton.textContent = originalText; screenshotButton.disabled = false; }, 2000); }
                }, 'image/png');
            } catch (err) {
                console.error('Screenshot error:', err); screenshotButton.textContent = 'Error!'; alert(`Screenshot Error:\n${err.message}`);
                setTimeout(() => { screenshotButton.textContent = originalText; screenshotButton.disabled = false; }, 2000);
            }
        }

        // --- Message Display ---
        // No changes needed
        function showMessage(title, text, subtext = "", bonusAlert = "") {
            messageTitle.textContent = title; messageText.textContent = text;
            messageSubText.style.display = subtext ? 'block' : 'none'; messageSubText.textContent = subtext;
            messageBonusText.style.display = bonusAlert ? 'block' : 'none'; messageBonusText.textContent = bonusAlert;
            goToStoreButton.style.display = 'none'; skipStoreButton.style.display = 'none';
            messageBox.style.display = 'block';
        }
        function hideMessage() {
            messageBox.style.display = 'none'; goToStoreButton.style.display = 'none'; skipStoreButton.style.display = 'none';
        }

        // --- Store Logic ---
        // Most store logic remains the same, but object creation uses ratios
        function updateStoreUI() { /* Logic remains the same */
            storeScoreDisplay.textContent = `Current Score: $${score}`;
            stockSatelliteDisplay.textContent = `Stock: ${storeStockSatellite}`; stockBaseDisplay.textContent = `Stock: ${storeStockBase}`; stockCityDisplay.textContent = `Stock: ${storeStockCity}`; stockShieldDisplay.textContent = `Stock: ${storeStockShield}`; stockSatShieldDisplay.textContent = `Stock: ${storeStockSatShield}`; stockSonicWaveDisplay.textContent = `Stock: ${storeStockSonicWave}`; stockBombDisplay.textContent = `Stock: ${storeStockBomb}`;
            const canAffordSatellite = score >= COST_SATELLITE; const satelliteInStock = storeStockSatellite > 0; const activeSatellites = satelliteBases.filter(s => s.alive).length; const canPlaceSatellite = activeSatellites < MAX_ACTIVE_SATELLITES;
            buySatelliteButton.disabled = !(canAffordSatellite && satelliteInStock && canPlaceSatellite);
            const canAffordBase = score >= COST_BASE; const baseInStock = storeStockBase > 0; const canRebuildBase = bases.some(b => !b.alive);
            buyBaseButton.disabled = !(canAffordBase && baseInStock && canRebuildBase);
            const canAffordCity = score >= COST_CITY; const cityInStock = storeStockCity > 0; const canRebuildCity = cities.some(c => !c.alive);
            buyCityButton.disabled = !(canAffordCity && cityInStock && canRebuildCity);
            const canAffordShield = score >= COST_SHIELD; const shieldInStock = storeStockShield > 0; const canPlaceShield = baseShields.some((shield, index) => bases[index].alive && (!shield || !shield.alive));
            buyShieldButton.disabled = !(canAffordShield && shieldInStock && canPlaceShield);
            const canAffordSatShield = score >= COST_SAT_SHIELD; const satShieldInStock = storeStockSatShield > 0; const canPlaceSatShield = satelliteBases.some(s => s.alive && (!s.shield || !s.shield.alive));
            buySatShieldButton.disabled = !(canAffordSatShield && satShieldInStock && canPlaceSatShield);
            const canAffordSonic = score >= COST_SONIC_WAVE; const sonicInStock = storeStockSonicWave > 0;
            buySonicWaveButton.disabled = !(canAffordSonic && sonicInStock);
            const canAffordBomb = score >= COST_BOMB; const bombInStock = storeStockBomb > 0;
            buyBombButton.disabled = !(canAffordBomb && bombInStock);
        }
        function findAndRebuildBase() { /* Logic remains the same */
            const deadBaseIndex = bases.findIndex(b => !b.alive);
            if (deadBaseIndex !== -1) { bases[deadBaseIndex].alive = true; bases[deadBaseIndex].ammo = selectedDifficultyAmmo; return true; } return false;
        }
        function findAndRebuildCity() { /* Logic remains the same */
            const deadCityIndex = cities.findIndex(c => !c.alive);
            if (deadCityIndex !== -1) { cities[deadCityIndex].alive = true; return true; } return false;
        }
        function buyReplacementBase() { /* Logic remains the same */
            if (score >= COST_BASE && storeStockBase > 0) { if (findAndRebuildBase()) { score -= COST_BASE; storeStockBase--; updateStoreUI(); updateUI(); } }
        }
        function buyReplacementCity() { /* Logic remains the same */
            if (score >= COST_CITY && storeStockCity > 0) { if (findAndRebuildCity()) { score -= COST_CITY; storeStockCity--; updateStoreUI(); updateUI(); } }
        }
        function buySatellite() {
            const activeSatellitesCount = satelliteBases.filter(s => s.alive).length;
            if (score >= COST_SATELLITE && storeStockSatellite > 0 && activeSatellitesCount < MAX_ACTIVE_SATELLITES) {
                let placed = false;
                const basePositionsRatios = [0.15, 0.5, 0.85]; // Use the same ratios
                for (let i = 0; i < 3; i++) {
                    const targetX = basePositionsRatios[i] * canvas.width; // Target X based on ratio
                    const satelliteX = targetX - (canvas.width * SATELLITE_WIDTH_RATIO / 2); // Center satellite X
                    const positionOccupied = satelliteBases.some(s => s.alive && Math.abs(s.x - satelliteX) < 1);
                    if (!positionOccupied) {
                        score -= COST_SATELLITE; storeStockSatellite--;
                        // Create satellite using ratios
                        const newSatellite = createSatelliteBase(basePositionsRatios[i], SATELLITE_Y_POS_RATIO);
                        satelliteBases.push(newSatellite);
                        placed = true; break;
                    }
                }
                updateStoreUI(); updateUI();
            }
        }
        function buyShield() { /* Logic remains the same */
            if (score >= COST_SHIELD && storeStockShield > 0) {
                let shieldPlaced = false;
                for (let i = 0; i < bases.length; i++) {
                    if (bases[i].alive && (!baseShields[i] || !baseShields[i].alive)) {
                        score -= COST_SHIELD; storeStockShield--; baseShields[i] = { alive: true, strength: SHIELD_STRENGTH_START, flashTimer: 0 };
                        shieldPlaced = true; break;
                    }
                }
                updateStoreUI(); updateUI();
            }
        }
        function buySatShield() { /* Logic remains the same */
            if (score >= COST_SAT_SHIELD && storeStockSatShield > 0) {
                let shieldPlaced = false;
                for (let i = 0; i < satelliteBases.length; i++) {
                    const sat = satelliteBases[i];
                    if (sat.alive && (!sat.shield || !sat.shield.alive)) {
                        score -= COST_SAT_SHIELD; storeStockSatShield--; sat.shield = { alive: true, strength: SHIELD_STRENGTH_START, flashTimer: 0 };
                        shieldPlaced = true; break;
                    }
                }
                updateStoreUI(); updateUI();
            }
        }
        function buySonicWave() { /* Logic remains the same */
            if (score >= COST_SONIC_WAVE && storeStockSonicWave > 0) { score -= COST_SONIC_WAVE; storeStockSonicWave--; inventorySonicWave++; updateStoreUI(); updateSpecialWeaponsUI(); }
        }
        function buyBomb() { /* Logic remains the same */
             if (score >= COST_BOMB && storeStockBomb > 0) { score -= COST_BOMB; storeStockBomb--; inventoryBomb++; updateStoreUI(); updateSpecialWeaponsUI(); }
        }

        // --- Special Weapon Logic ---
        // Uses internal coordinates - no changes needed for core logic
        function updateSpecialWeaponsUI() { /* Logic remains the same */
            sonicWaveCountDisplay.textContent = inventorySonicWave; bombCountDisplay.textContent = inventoryBomb;
            const canUseSpecials = gameHasStarted && !isGameOver && !isPaused && !transitioningLevel;
            sonicWaveControl.classList.toggle('disabled', inventorySonicWave <= 0 || !canUseSpecials || activeSonicWave);
            bombControl.classList.toggle('disabled', inventoryBomb <= 0 || !canUseSpecials);
            bombControl.classList.toggle('armed', isBombArmed);
            canvas.style.cursor = isBombArmed ? 'cell' : 'crosshair';
        }
        function triggerSonicWave() {
            if (inventorySonicWave > 0 && !activeSonicWave && !sonicWaveControl.classList.contains('disabled')) {
                 inventorySonicWave--;
                 // Start wave at the ground based on ratio
                 activeSonicWave = { y: canvas.height - (canvas.height * GROUND_HEIGHT_RATIO), alive: true };
                 updateSpecialWeaponsUI();
            }
        }
        function armBomb() { /* Logic remains the same */
             if (inventoryBomb > 0 && !bombControl.classList.contains('disabled')) { isBombArmed = !isBombArmed; updateSpecialWeaponsUI(); }
        }
        function deployBomb(clickX, clickY) { /* Logic remains the same */
             if (isBombArmed) {
                 inventoryBomb--; isBombArmed = false;
                 const bombRadius = EXPLOSION_RADIUS_MAX * BOMB_EXPLOSION_RADIUS_MULTIPLIER;
                 const bombDuration = EXPLOSION_DURATION * BOMB_EXPLOSION_DURATION_MULTIPLIER;
                 createExplosion(clickX, clickY, EXPLOSION_RADIUS_START, '#ffffff', bombRadius, bombDuration);
                 updateSpecialWeaponsUI();
             }
        }

        // --- Drawing Functions ---
        // Adjusted to use ratios where appropriate
        function drawBackground() {
            // Background color
            ctx.fillStyle = '#00001a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars (relative to current canvas size)
            ctx.fillStyle = 'white';
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            const numStars = Math.floor(canvas.width * canvas.height / 5000); // Scale stars with area
            for (let i = 0; i < numStars; i++) {
                let x = Math.random() * canvas.width;
                let y = Math.random() * groundY; // Don't draw stars on the ground
                let radius = Math.random() * 1.5;
                ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
            }

            // Ground (using ratio)
            ctx.fillStyle = '#3b2e1a';
            ctx.fillRect(0, groundY, canvas.width, canvas.height * GROUND_HEIGHT_RATIO);
        }
        function drawGameObjects() {
            // Draw Cities and Bases (their draw methods handle scaling)
            cities.forEach(city => city.draw());
            bases.forEach(base => base.draw());

            // Draw Satellites and their Shields (their draw methods handle scaling)
            satelliteBases.forEach(sat => {
                sat.draw();
                if (sat.shield && sat.shield.alive) {
                    const shieldCenterX = sat.x + sat.width / 2; const shieldCenterY = sat.y + sat.height / 2;
                    const shieldRadiusX = sat.width * 0.6 + 4; const shieldRadiusY = sat.height * 0.8 + 4;
                    let shieldColor = SHIELD_COLOR_25;
                    if (sat.shield.strength > 75) shieldColor = SHIELD_COLOR_FULL;
                    else if (sat.shield.strength > 50) shieldColor = SHIELD_COLOR_75;
                    else if (sat.shield.strength > 25) shieldColor = SHIELD_COLOR_50;
                    if (sat.shield.flashTimer > 0) { shieldColor = SHIELD_FLASH_COLOR; sat.shield.flashTimer--; }
                    ctx.beginPath(); ctx.ellipse(shieldCenterX, shieldCenterY, shieldRadiusX, shieldRadiusY, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = shieldColor; ctx.lineWidth = 2; ctx.stroke(); ctx.lineWidth = 1;
                }
            });

            // Draw Base Shields
            for (let i = 0; i < baseShields.length; i++) {
                const shield = baseShields[i];
                if (shield && shield.alive) {
                    const base = bases[i];
                    const shieldCenterX = base.x + base.width / 2;
                    // MODIFIED: Increase original radius calculation by 80% (multiply by 1.80) - per user diff
                    const shieldRadius = 1.80 * ((base.width / 2) + (canvas.width * CITY_WIDTH_RATIO / 2) + 5);
                    let shieldColor = SHIELD_COLOR_25;
                    if (shield.strength > 75) shieldColor = SHIELD_COLOR_FULL;
                    else if (shield.strength > 50) shieldColor = SHIELD_COLOR_75;
                    else if (shield.strength > 25) shieldColor = SHIELD_COLOR_50;
                    if (shield.flashTimer > 0) { shieldColor = SHIELD_FLASH_COLOR; shield.flashTimer--; }

                    // --- MODIFIED: Replacement for ctx.arc to draw a flatter shield ---
                    const startX = shieldCenterX - shieldRadius;
                    const endX = shieldCenterX + shieldRadius;
                    // MODIFIED: Changed -5 to -15 to move shield higher
                    const shieldTopY = base.y - 15; // Bottom edge Y coordinate (ends of the curve)
                    // CORRECTED: Adjust the control point Y to be ABOVE shieldTopY for an upward curve.
                    // Adjust the multiplier (0.3 here) to control flatness. Smaller = flatter, Larger = more curved.
                    const controlY = shieldTopY - shieldRadius * 0.3;

                    ctx.beginPath();
                    ctx.moveTo(startX, shieldTopY);
                    ctx.quadraticCurveTo(shieldCenterX, controlY, endX, shieldTopY);
                    ctx.strokeStyle = shieldColor;
                    ctx.lineWidth = 3; // Keep line width
                    ctx.stroke();
                    ctx.lineWidth = 1; // Reset line width for other drawings
                    // --- End of modification ---
                }
            }

            // Draw Sonic Wave if active
            if (activeSonicWave && activeSonicWave.alive) {
                 ctx.fillStyle = SONIC_WAVE_COLOR;
                 ctx.fillRect(0, activeSonicWave.y - SONIC_WAVE_HEIGHT, canvas.width, SONIC_WAVE_HEIGHT);
                 ctx.strokeStyle = 'rgba(255, 100, 255, 0.8)'; ctx.lineWidth = 1;
                 const numLines = 5;
                 for(let i=0; i < numLines; i++) {
                     const lineY = activeSonicWave.y - (SONIC_WAVE_HEIGHT / numLines * (i + 0.5));
                     ctx.beginPath(); ctx.moveTo(0, lineY); ctx.lineTo(canvas.width, lineY); ctx.stroke();
                 }
            }

            // Draw Missiles and Explosions (their draw methods use internal coords)
            incomingMissiles.forEach(missile => missile.draw());
            playerMissiles.forEach(missile => missile.draw());
            explosions.forEach(explosion => explosion.draw());
        }

        // --- Update Functions ---
        // Adjusted to use ratios where appropriate
        function updateGameObjects() {
            // Spawn missiles (logic remains the same)
            if (!isGameOver && !transitioningLevel && missilesToSpawn > 0 && Math.random() < 0.015 * (1 + level * 0.1)) {
                incomingMissiles.push(createIncomingMissile()); missilesToSpawn--;
            }

            // Update Sonic Wave
            if (activeSonicWave && activeSonicWave.alive) {
                 activeSonicWave.y -= SONIC_WAVE_SPEED;
                 const waveTop = activeSonicWave.y - SONIC_WAVE_HEIGHT; const waveBottom = activeSonicWave.y;
                 incomingMissiles.forEach(missile => {
                     if (missile.alive && missile.y >= waveTop && missile.y <= waveBottom) {
                         missile.alive = false; score += POINTS_PER_MISSILE;
                         createExplosion(missile.x, missile.y, EXPLOSION_RADIUS_START, missile.color);
                     }
                 });
                 if (waveTop <= 0) { activeSonicWave.alive = false; activeSonicWave = null; updateSpecialWeaponsUI(); }
            }

            // Update missiles and explosions (use internal coords)
            incomingMissiles.forEach(missile => missile.update());
            playerMissiles.forEach(missile => missile.update());
            explosions.forEach(explosion => explosion.update());

            // Filter dead objects
            incomingMissiles = incomingMissiles.filter(missile => missile.alive);
            playerMissiles = playerMissiles.filter(missile => missile.alive);
            explosions = explosions.filter(explosion => explosion.alive);
        }
        function updateUI() { /* Logic remains the same */
            scoreDisplay.textContent = `SCORE: $${score}`; levelDisplay.textContent = `LEVEL: ${level}`;
            const livingCities = cities.filter(c => c.alive).length; citiesLeftDisplay.textContent = `CITIES: ${livingCities}`;
            bonusIndicator.style.display = bonusMissileCount > 0 ? 'inline-block' : 'none';
            if (bonusMissileCount > 0) { bonusIndicator.textContent = `BONUS FIRE +${bonusMissileCount}!`; }
        }

        // --- Game Loop ---
        function gameLoop() {
            if (isPaused) { gameLoopId = null; return; }
            checkGameOverConditions();
            if (isGameOver && explosions.length === 0 && !activeSonicWave && !transitioningLevel) { gameLoopId = null; return; }

            // --- Clear and Draw ---
            // Clear the entire canvas before drawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawGameObjects();

            // --- Updates ---
            if (!isGameOver && !transitioningLevel) {
                updateGameObjects(); updateUI(); updateSpecialWeaponsUI(); checkLevelEnd();
            } else if (isGameOver) {
                explosions.forEach(explosion => explosion.update()); explosions = explosions.filter(explosion => explosion.alive);
                 if (activeSonicWave && activeSonicWave.alive) {
                     activeSonicWave.y -= SONIC_WAVE_SPEED;
                     if (activeSonicWave.y - SONIC_WAVE_HEIGHT <= 0) { activeSonicWave.alive = false; activeSonicWave = null; }
                 }
            }

            // Request next frame
            if (!isGameOver || explosions.length > 0 || activeSonicWave) { gameLoopId = requestAnimationFrame(gameLoop); }
            else { gameLoopId = null; }
        }

        // --- Event Listeners ---
        // Canvas Click - IMPORTANT: Scaling logic already exists and should work
        canvas.addEventListener('click', (event) => {
            if (isGameOver || isPaused || transitioningLevel || !gameHasStarted) return;
            const rect = canvas.getBoundingClientRect();
            // Calculate scale based on *internal* vs *display* size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (event.clientX - rect.left) * scaleX;
            const clickY = (event.clientY - rect.top) * scaleY;
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);

            if (clickY < 20 || clickY > groundY) return; // Ignore clicks too high or low

            if (isBombArmed) { deployBomb(clickX, clickY); return; }

            let nearestSource = null; let minDistance = Infinity;
            bases.forEach(base => { // Check ground bases
                if (base.alive && base.ammo > 0) {
                    const sourceCenterX = base.x + base.width / 2; const sourceTopY = base.y;
                    const d = distance(clickX, clickY, sourceCenterX, sourceTopY);
                    if (d < minDistance) { minDistance = d; nearestSource = base; }
                }
            });
            satelliteBases.forEach(sat => { // Check satellite bases
                if (sat.alive && sat.ammo > 0) {
                    const sourceCenterX = sat.x + sat.width / 2; const sourceTopY = sat.y + sat.height;
                    const d = distance(clickX, clickY, sourceCenterX, sourceTopY);
                    if (d < minDistance) { minDistance = d; nearestSource = sat; }
                }
            });

            if (nearestSource) {
                const startX = nearestSource.x + nearestSource.width / 2;
                const startY = nearestSource.isSatellite ? nearestSource.y + nearestSource.height : nearestSource.y;
                const totalMissilesToFire = 1 + bonusMissileCount;
                const actualMissilesToFire = Math.min(totalMissilesToFire, nearestSource.ammo);
                if (actualMissilesToFire > 0) {
                    nearestSource.ammo -= actualMissilesToFire;
                    for (let i = 0; i < actualMissilesToFire; i++) {
                        const currentOffset = (i - (actualMissilesToFire - 1) / 2) * BONUS_FIRE_SPREAD;
                        playerMissiles.push(createPlayerMissile(startX + currentOffset, startY, clickX, clickY));
                    }
                }
            }
        });

        // Restart Button - Reset UI to initial responsive state
        restartButton.addEventListener('click', () => {
            if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
            isGameOver = true; gameHasStarted = false; isPaused = false; transitioningLevel = false; difficultySelected = false; bonusMissileCount = 0;
            storeStockSatellite = MAX_STOCK; storeStockBase = MAX_STOCK; storeStockCity = MAX_STOCK; storeStockShield = MAX_SHIELD_STOCK; storeStockSatShield = MAX_SAT_SHIELD_STOCK; storeStockSonicWave = MAX_SONIC_WAVE_STOCK; storeStockBomb = MAX_BOMB_STOCK;
            inventorySonicWave = 0; inventoryBomb = 0; isBombArmed = false; activeSonicWave = null;
            satelliteBases = []; baseShields = [null, null, null]; cities = []; bases = []; incomingMissiles = []; playerMissiles = []; explosions = [];

            // Reset UI
            startMenuContainer.style.display = 'flex';
            canvasContainer.style.display = 'none'; // Hide container
            canvas.style.display = 'none'; // Hide canvas
            uiContainer.style.display = 'none';
            controlsContainer.style.display = 'none';
            specialWeaponsUIDiv.style.display = 'none';
            pauseOverlay.style.display = 'none';
            hideMessage();
            storeModal.style.display = 'none';
            actualStartButton.style.display = 'none'; actualStartButton.disabled = true;
            restartButton.style.display = 'none'; pauseButton.style.display = 'none'; screenshotButton.style.display = 'none';
            bonusIndicator.style.display = 'none';
            document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('selected'));
        });

        // Other Event Listeners (No changes needed)
        pauseButton.addEventListener('click', togglePause);
        screenshotButton.addEventListener('click', saveScreenshot);
        storeContinueButton.addEventListener('click', proceedToNextLevel);
        buyBaseButton.addEventListener('click', buyReplacementBase);
        buyCityButton.addEventListener('click', buyReplacementCity);
        buySatelliteButton.addEventListener('click', buySatellite);
        buyShieldButton.addEventListener('click', buyShield);
        buySatShieldButton.addEventListener('click', buySatShield);
        buySonicWaveButton.addEventListener('click', buySonicWave);
        buyBombButton.addEventListener('click', buyBomb);
        goToStoreButton.addEventListener('click', () => { hideMessage(); updateStoreUI(); storeModal.style.display = 'block'; });
        skipStoreButton.addEventListener('click', proceedToNextLevel);
        document.querySelectorAll('.difficulty-button').forEach(button => {
            button.addEventListener('click', (event) => {
                selectedDifficultyAmmo = parseInt(event.target.getAttribute('data-ammo'), 10); difficultySelected = true;
                document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('selected')); event.target.classList.add('selected');
                actualStartButton.style.display = 'inline-block'; actualStartButton.disabled = false;
            });
        });
        actualStartButton.addEventListener('click', () => { if (difficultySelected) { startGame(); } });
        sonicWaveControl.addEventListener('click', () => { if (!sonicWaveControl.classList.contains('disabled')) { triggerSonicWave(); } });
        bombControl.addEventListener('click', () => { if (!bombControl.classList.contains('disabled')) { armBomb(); } });
        window.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && !isGameOver && !transitioningLevel && gameHasStarted && storeModal.style.display === 'none' && messageBox.style.display === 'none' ) {
                event.preventDefault(); togglePause();
            }
        });

        // --- Initial Setup on Page Load ---
        window.onload = () => {
            // Set initial canvas size (internal resolution)
            canvas.width = INTERNAL_WIDTH;
            canvas.height = INTERNAL_HEIGHT;

            // Ensure only the start menu is visible initially
            startMenuContainer.style.display = 'flex';
            canvasContainer.style.display = 'none'; // Hide container
            canvas.style.display = 'none'; // Hide canvas
            uiContainer.style.display = 'none';
            controlsContainer.style.display = 'none';
            specialWeaponsUIDiv.style.display = 'none';
            messageBox.style.display = 'none';
            storeModal.style.display = 'none';
            pauseOverlay.style.display = 'none';
            actualStartButton.style.display = 'none';
            restartButton.style.display = 'none';
            pauseButton.style.display = 'none';
            screenshotButton.style.display = 'none';
            bonusIndicator.style.display = 'none';

            // --- PWA: Register Service Worker ---
            // Check if the browser supports service workers
            if ('serviceWorker' in navigator) {
                // Register the service worker file (sw.js)
                navigator.serviceWorker.register('/sw.js') // Path relative to the root of your site
                .then((registration) => {
                    // Log success
                    console.log('[Service Worker] registered with scope:', registration.scope);
                })
                .catch((error) => {
                    // Log failure
                    console.error('[Service Worker] registration failed:', error);
                });
            } else {
                // Log if service workers are not supported
                console.log('[Service Worker] not supported in this browser.');
            }
        };

        // Optional: Add resize listener if complex dynamic resizing is needed,
        // but CSS aspect-ratio and scaling clicks should handle most cases.
        // window.addEventListener('resize', () => {
        //    // Potentially redraw or recalculate element positions if CSS isn't enough
        //    // Be careful with performance here
        //    if (gameHasStarted && !isPaused) {
        //        // Example: Force a redraw if needed
        //        drawBackground();
        //        drawGameObjects();
        //    }
        // });

    </script>

</body>
</html>
