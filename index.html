<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="Missile Command - Atari Classic Clone Game">
    <meta name="theme-color" content="#000000"/>
    <link rel="preload" href="/css/fonts.css" as="style">
    <link rel="preload" href="/fonts/press-start-2p-v15-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.json">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Missile Cmd">
    <title>Missile Command</title>
    <link href="/css/fonts.css" rel="stylesheet">
    <style>
        /* --- General Body and Font --- */
        html, body { height: 100%; margin: 0; padding: 0; overflow-x: hidden; overflow-y: auto; }
        body { display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 10px; box-sizing: border-box; min-height: 100vh; background-color: #000; font-family: 'Press Start 2P', cursive; color: #00ff00; }

        /* --- Game Title --- */
        h1#mainTitle { color: #ff0000; font-size: clamp(20px, 5vw, 32px); margin-bottom: 15px; text-shadow: 2px 2px #ffff00; text-align: center; }

        /* --- Game Canvas Container --- */
        #canvasContainer { position: relative; width: 100%; max-width: 800px; aspect-ratio: 800 / 600; margin: 0 auto; }

        /* --- Game Canvas --- */
        #gameCanvas { display: none; background-color: #111; border: 2px solid #00ff00; box-shadow: 0 0 15px #00ff00; cursor: crosshair; width: 100%; height: 100%; image-rendering: pixelated; position: absolute; top: 0; left: 0; }

        /* --- UI Container --- */
        #uiContainer { display: none; flex-wrap: wrap; justify-content: space-around; align-items: center; width: 100%; max-width: 800px; padding: 8px 0; font-size: clamp(9px, 2.5vw, 11px); gap: 8px; border-bottom: 1px solid #005500; margin-bottom: 5px; }
        #score, #highScore, #wave, #citiesLeft, #multiplier { flex-grow: 1; text-align: center; min-width: 80px; }
        #highScore { color: #aaa; }
        #multiplier { color: #ffff00; font-weight: bold; text-shadow: 1px 1px #000; }

        /* --- Bonus Indicator --- */
        #bonusIndicator { color: #ffaa00; font-weight: bold; text-shadow: 1px 1px #000; display: none; order: 5; text-align: center; flex-basis: 100%; margin-top: 5px; }

        /* --- Controls Container --- */
        #controlsContainer { margin-top: 10px; display: none; flex-wrap: wrap; justify-content: center; gap: 10px; width: 100%; max-width: 800px; }

        /* --- Special Weapons UI --- */
        #specialWeaponsUI { background-color: #222; border: 1px solid #444; border-radius: 8px; padding: 8px 10px; margin-top: 10px; display: none; flex-wrap: wrap; gap: 15px; justify-content: center; align-items: center; width: auto; max-width: 95%; }
        .weaponControl { display: flex; flex-direction: column; align-items: center; cursor: pointer; border: 2px solid transparent; padding: 5px; border-radius: 5px; transition: border-color 0.3s, background-color 0.3s; }
        .weaponControl.armed { border-color: #ff0000; background-color: rgba(255, 0, 0, 0.2); }
        .weaponControl:hover:not(.disabled) { background-color: rgba(0, 255, 0, 0.1); }
        .weaponControl.disabled { opacity: 0.4; cursor: not-allowed; }
        .weaponIcon { font-size: clamp(18px, 4vw, 24px); width: 30px; height: 30px; line-height: 30px; text-align: center; border: 1px solid #888; border-radius: 4px; margin-bottom: 4px; }
        .weaponCount { font-size: clamp(10px, 2vw, 12px); color: #ffff00; }

        /* --- Start Menu --- */
        #startMenuContainer { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 600px; padding: 10px; box-sizing: border-box; }
        #difficultySelection { display: flex; flex-direction: column; align-items: stretch; gap: 10px; margin-top: 0; padding: 15px; border: 2px solid #ffff00; border-radius: 10px; background-color: rgba(30, 30, 0, 0.5); width: 100%; box-sizing: border-box; }
        #difficultySelection h3 { margin: 0 0 10px 0; color: #ffff00; font-size: clamp(16px, 4vw, 18px); text-align: center; }
        #startHighScore { color: #aaa; font-size: clamp(12px, 3vw, 14px); margin-top: 15px; text-align: center; }

        /* --- Buttons --- */
        button { font-family: 'Press Start 2P', cursive; background-color: #333; color: #00ff00; border: 2px solid #00ff00; padding: 8px 15px; font-size: clamp(12px, 3vw, 16px); cursor: pointer; box-shadow: 0 0 8px #00ff00 inset; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; border-radius: 5px; white-space: nowrap; flex-grow: 0; flex-shrink: 1; }
        .difficulty-button { border-color: #ffff00; color: #ffff00; box-shadow: 0 0 8px #ffff00 inset; min-width: auto; text-align: center; }
        .difficulty-button:hover:not(:disabled), .difficulty-button:focus:not(:disabled) { box-shadow: 0 0 12px #ffff00 inset, 0 0 8px #ffff00; background-color: #444; }
        .difficulty-button.selected { background-color: #555500; box-shadow: 0 0 12px #ffff00 inset, 0 0 12px #ffff00; color: #fff; }
        #actualStartButton { margin-top: 20px; display: none; }
        button:hover:not(:disabled), button:focus:not(:disabled) { background-color: #444; outline: none; }
        button:not(.difficulty-button):hover:not(:disabled) { box-shadow: 0 0 12px #00ff00 inset, 0 0 8px #00ff00; }
        button:active:not(:disabled) { background-color: #222; }
        button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }

        /* --- Message Box --- */
        #messageBox { position: fixed; top: 35%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.9); border: 3px solid #ff0000; padding: 20px; text-align: center; color: #ff0000; display: none; z-index: 30; box-shadow: 0 0 20px #ff0000; border-radius: 10px; width: 90%; max-width: 670px; box-sizing: border-box; max-height: 85vh; overflow-y: auto; padding-bottom: 25px; } /* Added padding-bottom */
        #messageBox h2 { margin: 0 0 10px 0; font-size: clamp(20px, 5vw, 32px); }
        #messageBox p { margin: 5px 0 10px 0; font-size: clamp(12px, 3vw, 16px); color: #ffff00; line-height: 1.4; }
        #messageBox p.bonus-alert { color: #ffaa00; font-weight: bold; display: block; min-height: 1em; margin-top: 8px; }
        #statsContainer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #550000;
            font-size: clamp(10px, 2.5vw, 11.5px);
            color: #ccc;
            text-align: left;
            display: grid; /* Use Grid for layout */
            grid-template-columns: 1fr 1fr; /* Two equal columns */
            gap: 5px 15px; /* Row gap, Column gap */
        }
        #statsContainer span {
            display: block;
            margin-bottom: 4px;
            white-space: nowrap;
        }
        .messageBoxButtons { margin-top: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        #goToStoreButton, #skipStoreButton { display: none; }

        /* --- Pause Overlay --- */
        #pauseOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: #ffff00; display: none; align-items: center; justify-content: center; font-size: clamp(30px, 10vw, 48px); text-shadow: 3px 3px #ff0000; z-index: 15; pointer-events: none; }

        /* --- Store Modal --- */
        #storeModal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 650px; max-height: 80vh; background-color: rgba(0, 20, 0, 0.9); border: 3px solid #00ff00; border-radius: 15px; box-shadow: 0 0 25px #00ff00; padding: 15px; z-index: 20; display: none; color: #00ff00; font-size: clamp(11px, 2.5vw, 11.5px); box-sizing: border-box; overflow-y: auto; }
        #storeModal h2 { font-size: clamp(20px, 5vw, 22px); margin: 0 0 15px 0; text-align: center; color: #ffff00; }
        #storeScore { font-size: clamp(14px, 3.5vw, 15px); margin-bottom: 15px; text-align: center; color: #fff; }
        #storeItemsContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .storeItem { padding: 10px; background-color: rgba(0, 50, 0, 0.7); border-radius: 5px; border: 1px solid #008800; display: flex; flex-direction: column; justify-content: space-between; min-height: 100px; }
        .storeItemInfo { margin-bottom: 8px; }
        .storeItemInfo span { display: block; margin-bottom: 3px; }
        .itemCost { color: #ffff00; }
        .itemStock, .itemLevel { color: #aaa; font-size: clamp(10px, 2vw, 12px); }
        .storeItemButtons { display: flex; flex-wrap: wrap; gap: 5px; align-items: center; justify-content: flex-end; margin-top: 5px; }
        .buyButton { padding: 6px 12px; font-size: clamp(11px, 2.5vw, 14px); min-width: auto; flex-shrink: 1; }
        .buyMultipleButton { border-color: #00aaaa; color: #00cccc; box-shadow: 0 0 6px #00aaaa inset; padding: 6px 8px; font-size: clamp(10px, 2.2vw, 12px); }
        .buyMultipleButton:hover:not(:disabled) { box-shadow: 0 0 10px #00aaaa inset, 0 0 6px #00aaaa; }
        #storeContinueButton { display: block; margin: 20px auto 0 auto; }

        /* --- Footer --- */
        footer { width: 100%; max-width: 800px; margin-top: 20px; padding: 10px 0; border-top: 1px solid #005500; font-size: clamp(10px, 2.5vw, 12px); display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 10px; }
        footer a { color: #00ff00; text-decoration: none; transition: color 0.3s, text-shadow 0.3s; display: inline-block; vertical-align: middle; line-height: 1; margin: 0 5px; }
        footer a:hover, footer a:focus { color: #ffff00; text-shadow: 0 0 5px #ffff00; outline: none; }
        footer a img { vertical-align: middle; margin: 0 3px; height: 20px; width: auto; }
        footer .link-group { }

        /* --- Leaderboard Styles --- */
        #leaderboardContainer {
            margin-top: 20px;
            padding: 15px;
            border: 2px solid #00ffff; /* Cyan border */
            border-radius: 10px;
            background-color: rgba(0, 30, 30, 0.5);
            width: 100%;
            max-width: 400px; /* Adjust width as needed */
            box-sizing: border-box;
            color: #00ffff;
            display: none; /* Initially hidden */
            text-align: center;
        }
        #leaderboardContainer h3 {
            margin: 0 0 10px 0;
            font-size: clamp(16px, 4vw, 18px);
            color: #ffffff;
        }
        #leaderboardList {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: clamp(12px, 3vw, 14px);
            text-align: left;
            max-height: 200px; /* Limit height and add scroll if needed */
            overflow-y: auto;
        }
        #leaderboardList li {
            display: flex;
            justify-content: space-between;
            padding: 3px 5px;
            border-bottom: 1px dashed rgba(0, 255, 255, 0.3);
        }
         #leaderboardList li:last-child {
            border-bottom: none;
        }
        #leaderboardList .rank {
            flex-basis: 10%;
            text-align: right;
            padding-right: 10px;
            color: #aaaaaa;
        }
        #leaderboardList .name {
            flex-basis: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #leaderboardList .score {
            flex-basis: 40%;
            text-align: right;
            color: #ffff00;
        }
        #leaderboardLoading {
            color: #aaaaaa;
        }

        /* --- Game Over Score Submission Styles --- */
        #scoreSubmission {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #550000;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        #scoreSubmission label {
            font-size: clamp(11px, 2.8vw, 14px);
            color: #ffff00;
        }
        #playerNameInput {
            font-family: 'Press Start 2P', cursive;
            background-color: #222;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 8px;
            font-size: clamp(12px, 3vw, 16px);
            text-align: center;
            width: 320px; /* Adjust as needed */
            text-transform: uppercase;
            border-radius: 3px;
        }
        #submitScoreButton {
            /* Use existing button styles */
            margin-top: 5px;
        }
        #submissionStatus {
            margin-top: 5px;
            font-size: clamp(10px, 2.5vw, 12px);
            color: #00ff00;
            min-height: 1em; /* Prevent layout shift */
        }

        /* --- Media Queries --- */
        @media (max-width: 768px) {
            #uiContainer { gap: 6px; padding: 5px 0; font-size: clamp(9px, 2.2vw, 11px); }
            #controlsContainer { gap: 8px; }
            #specialWeaponsUI { gap: 10px; padding: 6px 8px; }
            #difficultySelection { gap: 8px; padding: 10px; }
            button { padding: 6px 12px; }
            #messageBox { padding: 15px; max-width: 95%; }
            #storeModal { padding: 10px; }
            /* Adjust store grid for medium screens */
            #storeItemsContainer { gap: 8px; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));}
            footer { margin-top: 15px; gap: 8px; }
            footer a { margin: 0 4px; }
            footer a img { margin: 0 2px; height: 18px; }
            .storeItem { flex-direction: column; align-items: stretch; padding: 8px 10px; min-height: 0; gap: 8px; }
            .storeItemInfo { margin-bottom: 5px; flex-grow: 0; }
            .storeItemInfo span { display: block; margin-bottom: 2px; line-height: 1.2; }
            .storeItemButtons { justify-content: space-between; }
            .buyButton { align-self: center; flex-shrink: 0; }
        }

        @media (max-width: 480px) {
            body { padding: 5px; }
            h1#mainTitle { font-size: 18px; margin-bottom: 10px; }
            #uiContainer { font-size: 8px; gap: 4px; justify-content: space-between;}
            #score, #highScore, #wave, #citiesLeft, #multiplier { min-width: 55px; }
            #controlsContainer { gap: 5px; }
            #specialWeaponsUI { gap: 8px; padding: 5px; }
            #difficultySelection { padding: 8px; gap: 6px; }
            #difficultySelection h3 { font-size: 14px; margin-bottom: 8px; }
            button { padding: 5px 10px; font-size: 10px; }
            .difficulty-button { font-size: 11px; }
            #messageBox { padding: 10px; width: 95%; top: 45%; max-height: 80vh; }
            #messageBox h2 { font-size: 18px; }
            #messageBox p { font-size: 11px; }
            #statsContainer {
                font-size: 9px;
                grid-template-columns: 1fr; /* Switch to single column on small screens */
                gap: 3px 10px;
             }
            .messageBoxButtons { gap: 8px; }
            #storeModal { padding: 8px; width: 95%; max-height: 75vh; }
            #storeModal h2 { font-size: 18px; }
            #storeScore { font-size: 12px; }
            /* --- MODIFIED: Use auto-fit grid for store on small screens, aiming for 3 columns --- */
            #storeItemsContainer {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Aim for 3 columns if space allows */
                gap: 6px; /* Slightly reduced gap */
            }
            .storeItem { padding: 6px 8px; gap: 6px; }
            .storeItemInfo span { font-size: 10px; margin-bottom: 1px; line-height: 1.15; }
            .itemStock, .itemLevel { font-size: 9px; }
            .storeItemButtons { gap: 4px; }
            .buyButton { padding: 4px 8px; font-size: 10px; }
            .buyMultipleButton { padding: 4px 6px; font-size: 9px; }
            #pauseOverlay { font-size: 24px; }
            footer { margin-top: 10px; font-size: 9px; padding: 8px 0; display: block; text-align: center; }
            footer .link-group { display: block; margin-bottom: 5px; text-align: center; }
            footer .link-group a { display: inline-block; margin: 2px 5px; vertical-align: middle; }
            footer .link-group a img { margin: 0 2px; height: 16px; }

            /* Leaderboard specific adjustments for small screens */
             #leaderboardContainer {
                max-width: 95%;
             }
             #leaderboardList .rank { flex-basis: 15%; }
             #leaderboardList .name { flex-basis: 45%; }
             #leaderboardList .score { flex-basis: 40%; }
        }
    </style>
</head>
<body>

    <div id="startMenuContainer">
        <h1 id="mainTitle">MISSILE COMMAND</h1>
        <div id="difficultySelection">
            <h3>SELECT DIFFICULTY</h3>
            <button class="difficulty-button" data-ammo="150" data-multiplier="1.0">Easy (150 Ammo)</button>
            <button class="difficulty-button" data-ammo="100" data-multiplier="1.25">Normal (100 Ammo)</button>
            <button class="difficulty-button" data-ammo="75" data-multiplier="1.5">Hard (75 Ammo)</button>
            <button class="difficulty-button" data-ammo="50" data-multiplier="2.0">Insane (50 Ammo)</button>
        </div>
        <div id="startHighScore">High Score: $0</div>
        <div id="leaderboardContainer">
            <h3>Top Scores</h3>
            <ol id="leaderboardList">
                <li id="leaderboardLoading">Loading...</li>
            </ol>
        </div>
        <button id="actualStartButton" style="display: none;">Start Game</button> </div>

    <div id="uiContainer">
        <div id="score">SCORE: $0</div>
        <div id="highScore">HI: $0</div>
        <div id="wave">WAVE: 1</div>
        <div id="citiesLeft">CITIES: 6</div>
        <div id="multiplier">MULT: 1.0x</div>
        <div id="bonusIndicator">BONUS FIRE +0!</div>
    </div>

    <div id="canvasContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="pauseOverlay">PAUSED</div>
    </div>

    <div id="specialWeaponsUI">
        <div class="weaponControl" id="sonicWaveControl">
            <div class="weaponIcon">üåä</div>
            <span class="weaponCount" id="sonicWaveCount">0</span>
        </div>
        <div class="weaponControl" id="bombControl">
            <div class="weaponIcon">üí£</div>
            <span class="weaponCount" id="bombCount">0</span>
        </div>
    </div>

    <div id="controlsContainer">
        <button id="restartButton" style="display: none;">Restart Game</button>
        <button id="pauseButton" style="display: none;">Pause</button>
        <button id="screenshotButton" style="display: none;">Save Screenshot</button>
    </div>

    <div id="messageBox">
        <h2 id="messageTitle"></h2>
        <p id="messageText"></p>
        <p id="messageSubText"></p>
        <p id="messageBonusText" class="bonus-alert"></p>
        <div id="statsContainer" style="display: none;"> </div>
        <div id="scoreSubmission">
            <label for="playerNameInput">Enter Name (max 18 chars):</label>
            <input type="text" id="playerNameInput" maxlength="18" placeholder="ACE" size="18">
            <button id="submitScoreButton">Submit Score</button>
            <div id="submissionStatus"></div>
        </div>
        <div class="messageBoxButtons">
            <button id="goToStoreButton">Go to Store</button>
            <button id="skipStoreButton">Next Wave</button>
            <button id="restartButton" style="display: none;">Restart Game</button>
        </div>
    </div>

    <div id="storeModal">
        <h2>Inter-Wave Store</h2>
        <div id="storeScore">Current Score: $0</div>
        <div id="storeItemsContainer">
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Sonic Wave</span>
                    <span class="itemCost">Cost: $1000</span>
                    <span class="itemStock" id="stockSonicWave">Stock: 30</span>
                </div>
                <div class="storeItemButtons">
                    <button class="buyButton buyMultipleButton" id="buySonicWave10Button">BUY x10</button>
                    <button class="buyButton" id="buySonicWaveButton">BUY</button>
                </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Mega Bomb</span>
                    <span class="itemCost">Cost: $500</span>
                    <span class="itemStock" id="stockBomb">Stock: 30</span>
                </div>
                 <div class="storeItemButtons">
                    <button class="buyButton buyMultipleButton" id="buyBomb10Button">BUY x10</button>
                    <button class="buyButton" id="buyBombButton">BUY</button>
                </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Satellite Base (Max 3)</span>
                    <span class="itemCost">Cost: $4000</span>
                    <span class="itemStock" id="stockSatellite">Stock: 30</span>
                </div>
                 <div class="storeItemButtons"> <button class="buyButton" id="buySatelliteButton">BUY</button> </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Satellite Shield</span>
                    <span class="itemCost">Cost: $250</span>
                    <span class="itemStock" id="stockSatShield">Stock: 100</span>
                </div>
                 <div class="storeItemButtons"> <button class="buyButton" id="buySatShieldButton">BUY</button> </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Replacement Base</span>
                    <span class="itemCost">Cost: $1000</span>
                    <span class="itemStock" id="stockBase">Stock: 30</span>
                </div>
                 <div class="storeItemButtons"> <button class="buyButton" id="buyBaseButton">BUY</button> </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Replacement City</span>
                    <span class="itemCost">Cost: $2000</span>
                    <span class="itemStock" id="stockCity">Stock: 30</span>
                </div>
                 <div class="storeItemButtons"> <button class="buyButton" id="buyCityButton">BUY</button> </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Base Shield</span>
                    <span class="itemCost">Cost: $250</span>
                    <span class="itemStock" id="stockShield">Stock: 100</span>
                </div>
                 <div class="storeItemButtons"> <button class="buyButton" id="buyShieldButton">BUY</button> </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Faster Missiles (Max 5)</span>
                    <span class="itemCost" id="costFasterMissile">Cost: $1500</span>
                    <span class="itemLevel" id="levelFasterMissile">Level: 0/5</span>
                </div>
                 <div class="storeItemButtons"> <button class="buyButton" id="buyFasterMissileButton">BUY</button> </div>
            </div>
            <div class="storeItem">
                <div class="storeItemInfo">
                    <span>Wider Explosions (Max 5)</span>
                    <span class="itemCost" id="costWiderExplosion">Cost: $1200</span>
                    <span class="itemLevel" id="levelWiderExplosion">Level: 0/5</span>
                </div>
                 <div class="storeItemButtons"> <button class="buyButton" id="buyWiderExplosionButton">BUY</button> </div>
            </div>
        </div>
        <button id="storeContinueButton">Continue to Next Wave</button>
    </div>

    <footer>
        <div class="link-group social-links">
            <a href="https://x.com/George_SLiu" target="_blank" rel="noopener noreferrer">Twitter</a>
            <a href="https://www.threads.net/@george_sl_liu" target="_blank" rel="noopener noreferrer">Threads</a>
            <a href="https://bsky.app/profile/georgesl.bsky.social" target="_blank" rel="noopener noreferrer">BlueSky</a>
        </div>
        <div class="link-group github-links">
            <a href="https://github.com/sponsors/centminmod" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/sponsors/centminmod" alt="GitHub Sponsors" loading="lazy">
            </a>
            <a href="https://github.com/centminmod/atari-missile-command/stargazers" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/stars/centminmod/atari-missile-command.svg?style=flat-square" alt="Centmin Mod GitHub stars" loading="lazy">
            </a>
            <a href="https://github.com/centminmod/atari-missile-command/network" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/forks/centminmod/atari-missile-command.svg?style=flat-square" alt="Centmin Mod GitHub forks" loading="lazy">
            </a>
            <a href="https://github.com/centminmod/atari-missile-command/issues" target="_blank" rel="noopener noreferrer">
                <img src="https://img.shields.io/github/issues/centminmod/atari-missile-command.svg?style=flat-square" alt="Centmin Mod GitHub issues" loading="lazy">
            </a>
             <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è Vibe Jam 2025</a>
        </div>
    </footer>

    <script>
        // --- Canvas, Context, UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const waveDisplay = document.getElementById('wave');
        const citiesLeftDisplay = document.getElementById('citiesLeft');
        const multiplierDisplay = document.getElementById('multiplier');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const screenshotButton = document.getElementById('screenshotButton');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const messageSubText = document.getElementById('messageSubText');
        const messageBonusText = document.getElementById('messageBonusText');
        const statsContainer = document.getElementById('statsContainer');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const uiContainer = document.getElementById('uiContainer');
        const controlsContainer = document.getElementById('controlsContainer');
        const difficultySelectionDiv = document.getElementById('difficultySelection');
        const startMenuContainer = document.getElementById('startMenuContainer');
        const startHighScoreDisplay = document.getElementById('startHighScore');
        const actualStartButton = document.getElementById('actualStartButton');
        const bonusIndicator = document.getElementById('bonusIndicator');
        const goToStoreButton = document.getElementById('goToStoreButton');
        const skipStoreButton = document.getElementById('skipStoreButton');
        const storeModal = document.getElementById('storeModal');
        const storeScoreDisplay = document.getElementById('storeScore');
        const stockSatelliteDisplay = document.getElementById('stockSatellite');
        const stockBaseDisplay = document.getElementById('stockBase');
        const stockCityDisplay = document.getElementById('stockCity');
        const stockShieldDisplay = document.getElementById('stockShield');
        const stockSatShieldDisplay = document.getElementById('stockSatShield');
        const stockSonicWaveDisplay = document.getElementById('stockSonicWave');
        const stockBombDisplay = document.getElementById('stockBomb');
        const buySatelliteButton = document.getElementById('buySatelliteButton');
        const buyBaseButton = document.getElementById('buyBaseButton');
        const buyCityButton = document.getElementById('buyCityButton');
        const buyShieldButton = document.getElementById('buyShieldButton');
        const buySatShieldButton = document.getElementById('buySatShieldButton');
        const buySonicWaveButton = document.getElementById('buySonicWaveButton');
        const buyBombButton = document.getElementById('buyBombButton');
        const buySonicWave10Button = document.getElementById('buySonicWave10Button');
        const buyBomb10Button = document.getElementById('buyBomb10Button');
        const storeContinueButton = document.getElementById('storeContinueButton');
        const specialWeaponsUIDiv = document.getElementById('specialWeaponsUI');
        const sonicWaveControl = document.getElementById('sonicWaveControl');
        const sonicWaveCountDisplay = document.getElementById('sonicWaveCount');
        const bombControl = document.getElementById('bombControl');
        const bombCountDisplay = document.getElementById('bombCount');
        const canvasContainer = document.getElementById('canvasContainer');
        const costFasterMissileDisplay = document.getElementById('costFasterMissile');
        const levelFasterMissileDisplay = document.getElementById('levelFasterMissile');
        const buyFasterMissileButton = document.getElementById('buyFasterMissileButton');
        const costWiderExplosionDisplay = document.getElementById('costWiderExplosion');
        const levelWiderExplosionDisplay = document.getElementById('levelWiderExplosion');
        const buyWiderExplosionButton = document.getElementById('buyWiderExplosionButton');

        // --- NEW: Leaderboard Elements ---
        const leaderboardContainer = document.getElementById('leaderboardContainer');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardLoading = document.getElementById('leaderboardLoading');
        const scoreSubmissionDiv = document.getElementById('scoreSubmission');
        const playerNameInput = document.getElementById('playerNameInput');
        const submitScoreButton = document.getElementById('submitScoreButton');
        const submissionStatus = document.getElementById('submissionStatus');

        // --- Game Constants & State Variables ---
        const INTERNAL_WIDTH = 800;
        const INTERNAL_HEIGHT = 600;
        const GROUND_HEIGHT_RATIO = 10 / INTERNAL_HEIGHT;
        const BASE_WIDTH_RATIO = 40 / INTERNAL_WIDTH;
        const BASE_HEIGHT_RATIO = 40 / INTERNAL_HEIGHT;
        const CITY_WIDTH_RATIO = 50 / INTERNAL_WIDTH;
        const CITY_HEIGHT_RATIO = 30 / INTERNAL_HEIGHT;
        const SATELLITE_WIDTH_RATIO = 35 / INTERNAL_WIDTH;
        const SATELLITE_HEIGHT_RATIO = 25 / INTERNAL_HEIGHT;
        const SATELLITE_Y_POS_RATIO = (INTERNAL_HEIGHT * 0.55) / INTERNAL_HEIGHT;
        const MISSILE_SPEED_PLAYER_BASE = 5;
        const MISSILE_SPEED_ENEMY_BASE = 0.5;
        const MAX_ENEMY_MISSILE_SPEED = 3.5;
        const EXPLOSION_RADIUS_START = 13;
        const EXPLOSION_RADIUS_MAX_BASE = 65;
        const EXPLOSION_DURATION = 60;
        const POINTS_PER_MISSILE = 35;
        const POINTS_PER_CITY = 100;
        const POINTS_PER_AMMO = 5;
        const BONUS_FIRE_SPREAD = 8;
        const BASE_SHIELD_RADIUS_MULTIPLIER = 2.45;
        const SHIELD_STRENGTH_START = 100;
        const SHIELD_DAMAGE_PER_HIT = 10;
        const SHIELD_COLOR_FULL = 'rgba(0, 150, 255, 0.6)';
        const SHIELD_COLOR_75 = 'rgba(0, 255, 150, 0.6)';
        const SHIELD_COLOR_50 = 'rgba(255, 255, 0, 0.6)';
        const SHIELD_COLOR_25 = 'rgba(255, 100, 0, 0.6)';
        const SHIELD_FLASH_COLOR = 'rgba(255, 255, 255, 0.8)';
        const SHIELD_FLASH_DURATION = 5;
        const BOMB_EXPLOSION_RADIUS_MULTIPLIER = 5.5;
        const BOMB_EXPLOSION_DURATION_MULTIPLIER = 1.5;
        const SONIC_WAVE_SPEED = 4;
        const SONIC_WAVE_HEIGHT = 10;
        const SONIC_WAVE_COLOR = 'rgba(200, 0, 255, 0.5)';
        const ACCURACY_BONUS_THRESHOLD = 20;
        const ACCURACY_BONUS_POINTS = 50;
        const MULTIPLIER_INCREASE_INTERVAL = 5;
        const MULTIPLIER_MAX = 5.0;
        const COST_FASTER_MISSILE_BASE = 1500;
        const COST_WIDER_EXPLOSION_BASE = 1200;
        const UPGRADE_COST_MULTIPLIER = 1.8;
        const MAX_UPGRADE_LEVEL = 5;
        const MISSILE_SPEED_INCREASE_PER_LEVEL = 0.9;
        const EXPLOSION_RADIUS_INCREASE_PER_LEVEL = 8;
        const SMART_BOMB_CHANCE = 0.05;
        const SMART_BOMB_SPLIT_ALTITUDE_MIN = INTERNAL_HEIGHT * 0.45;
        const SMART_BOMB_SPLIT_ALTITUDE_MAX = INTERNAL_HEIGHT * 0.65;
        const SMART_BOMB_SPLIT_COUNT = 2;
        const SMART_BOMB_SPLIT_SPEED_FACTOR = 0.7;
        const SMART_BOMB_SPLIT_COLOR = '#ff8800';
        const MIRV_CHANCE = 0.10;
        const MIRV_SPLIT_ALTITUDE = INTERNAL_HEIGHT * 0.35;
        const MIRV_WARHEAD_COUNT = 4;
        const MIRV_WARHEAD_SPEED_FACTOR = 0.9;
        const MIRV_WARHEAD_COLOR = '#ff4444';
        const PLANE_SPEED_INCREASE_PER_WAVE = 0.05;
        const PLANE_VARIANT_CHANCE = 0.2;
        const MAX_ACTIVE_SATELLITES = 3;
        const COST_SATELLITE = 4000; const MAX_STOCK_SATELLITE = 100;
        const COST_BASE = 1000; const MAX_STOCK_BASE = 100;
        const COST_CITY = 2000; const MAX_STOCK_CITY = 100;
        const COST_SHIELD = 250; const MAX_STOCK_SHIELD = 100;
        const COST_SAT_SHIELD = 250; const MAX_STOCK_SAT_SHIELD = 100;
        const COST_SONIC_WAVE = 1000; const MAX_STOCK_SONIC_WAVE = 100;
        const COST_BOMB = 500; const MAX_STOCK_BOMB = 100;
        const PLANE_SPEED_BASE = 1.5;
        const PLANE_WIDTH = 50;
        const PLANE_HEIGHT = 20;
        const PLANE_BONUS_SCORE = 1000;
        const PLANE_BOMB_POINTS = 20;
        const PLANE_BOMB_SPEED = 1.0;
        const BASE_BOMBS_PER_PLANE = 10;
        const BOMBS_INCREASE_PER_WAVE = 1;
        const PLANE_SPAWN_CHANCE = 0.025;
        const PLANE_MIN_Y = INTERNAL_HEIGHT * 0.1;
        const PLANE_MAX_Y = INTERNAL_HEIGHT * 0.3;
        const PLANE_BOMB_DROP_INTERVAL_MIN = 80;
        const PLANE_BOMB_DROP_INTERVAL_MAX = 150;
        const PLANE_BOMB_COLOR = '#FFA500';
        const PLANE_BOMB_TRAIL_COLOR = 'rgba(255, 165, 0, 0.4)';

        // Game State Variables
        let score = 0;
        let gameTotalScore = 0;
        let highScore = 0;
        let currentWave = 0;
        let cities = [];
        let bases = [];
        let incomingMissiles = [];
        let playerMissiles = [];
        let explosions = [];
        let isGameOver = true;
        let gameLoopId = null;
        let transitioningWave = false;
        let isPaused = false;
        let gameHasStarted = false;
        let difficultySelected = false;
        let selectedDifficultyName = '';
        let selectedDifficultyAmmo = 50;
        let difficultyScoreMultiplier = 1.0;
        let bonusMissileCount = 0;
        let storeStockSatellite = MAX_STOCK_SATELLITE;
        let storeStockBase = MAX_STOCK_BASE;
        let storeStockCity = MAX_STOCK_CITY;
        let storeStockShield = MAX_STOCK_SHIELD;
        let storeStockSatShield = MAX_STOCK_SAT_SHIELD;
        let storeStockSonicWave = MAX_STOCK_SONIC_WAVE;
        let storeStockBomb = MAX_STOCK_BOMB;
        let satelliteBases = [];
        let baseShields = [null, null, null];
        let inventorySonicWave = 0;
        let inventoryBomb = 0;
        let isBombArmed = false;
        let activeSonicWave = null;
        let consecutiveIntercepts = 0;
        let scoreMultiplier = 1.0;
        let playerMissileSpeedLevel = 0;
        let explosionRadiusLevel = 0;
        let accuracyBonusMessageTimer = 0;
        let statsMissilesFired = 0;
        let statsEnemyMissilesDestroyed = 0;
        let statsPlaneBombsDestroyed = 0;
        let statsPlanesDestroyed = 0;
        let statsCitiesLost = 0;
        let statsBasesLost = 0;
        let statsAccuracyBonusHits = 0;
        let planes = [];
        let planeBombs = [];
        const waveDefinitions = defineWaves();
        let currentWaveConfig = {};
        let waveTimer = 0;
        let waveEnemiesSpawned = 0;
        let waveEnemiesRequired = 0;

        // --- Utility Functions ---
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function getRandomTarget(avoidX = -1, avoidRadius = 0) {
            const aliveCities = cities.filter(c => c.alive);
            const aliveBases = bases.filter(b => b.alive);
            const aliveSatellites = satelliteBases.filter(s => s.alive);
            let possibleTargets = [...aliveCities, ...aliveBases, ...aliveSatellites];
            if (avoidX !== -1) {
                possibleTargets = possibleTargets.filter(t => {
                    const targetCenterX = t.x + (t.width / 2);
                    return distance(targetCenterX, t.y, avoidX, 0) > avoidRadius;
                });
            }
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            if (possibleTargets.length === 0) {
                let targetGroundX = canvas.width / 2 + (Math.random() - 0.5) * canvas.width * 0.4;
                if (avoidX !== -1 && Math.abs(targetGroundX - avoidX) < avoidRadius) {
                    targetGroundX = avoidX + (Math.sign(targetGroundX - avoidX) || 1) * (avoidRadius + Math.random() * 50);
                    targetGroundX = Math.max(0, Math.min(canvas.width, targetGroundX));
                }
                return { x: targetGroundX, y: groundY };
            }
            const target = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
            return { x: target.x + (target.width / 2), y: target.y };
        }
        function getCurrentPlayerMissileSpeed() { return MISSILE_SPEED_PLAYER_BASE + (playerMissileSpeedLevel * MISSILE_SPEED_INCREASE_PER_LEVEL); }
        function getCurrentPlayerExplosionRadius() { return EXPLOSION_RADIUS_MAX_BASE + (explosionRadiusLevel * EXPLOSION_RADIUS_INCREASE_PER_LEVEL); }
        function calculateUpgradeCost(baseCost, level) { return Math.floor(baseCost * Math.pow(UPGRADE_COST_MULTIPLIER, level)); }

        // --- Game Object Factories ---
        function createCity(xRatio) {
            const cityWidth = canvas.width * CITY_WIDTH_RATIO;
            const cityHeight = canvas.height * CITY_HEIGHT_RATIO;
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            const cityX = xRatio * canvas.width;
            const cityY = groundY - cityHeight;
            const buildings = [];
            const numBuildings = 3 + Math.floor(Math.random() * 3);
            let currentX = cityX;
            const totalBuildingWidth = cityWidth * 0.9;
            const baseBuildingWidth = totalBuildingWidth / numBuildings;
            for (let i = 0; i < numBuildings; i++) {
                const buildingHeight = (cityHeight * 0.6) + (Math.random() * cityHeight * 0.4);
                const buildingWidth = baseBuildingWidth * (0.8 + Math.random() * 0.4);
                const gap = (baseBuildingWidth - buildingWidth) / 2;
                buildings.push({ x: currentX + gap, y: groundY - buildingHeight, w: buildingWidth, h: buildingHeight, color: `hsl(180, 100%, ${35 + Math.random() * 15}%)` });
                currentX += baseBuildingWidth;
            }
            return {
                x: cityX, y: cityY, width: cityWidth, height: cityHeight, alive: true, buildings: buildings,
                draw() {
                    if (!this.alive) return;
                    this.buildings.forEach(b => {
                        ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.w, b.h);
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        const windowSize = Math.min(b.w, b.h) * 0.15;
                        const cols = Math.floor(b.w / (windowSize * 2.5)); const rows = Math.floor(b.h / (windowSize * 3));
                        if (cols > 0 && rows > 0) {
                            const xSpacing = b.w / cols; const ySpacing = b.h / rows;
                            for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { ctx.fillRect(b.x + xSpacing * (c + 0.5) - windowSize / 2, b.y + ySpacing * (r + 0.5) - windowSize / 2, windowSize, windowSize); } }
                        }
                        ctx.strokeStyle = '#006666'; ctx.lineWidth = 1; ctx.strokeRect(b.x, b.y, b.w, b.h);
                    });
                }
            };
        }
        function createBase(xRatio) {
            const baseWidth = canvas.width * BASE_WIDTH_RATIO;
            const baseHeight = canvas.height * BASE_HEIGHT_RATIO;
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            const baseX = (xRatio * canvas.width) - (baseWidth / 2);
            const baseY = groundY - baseHeight;
            return {
                x: baseX, y: baseY, width: baseWidth, height: baseHeight, color: '#dddd00', outlineColor: '#aaaa00', launcherColor: '#999999', alive: true, ammo: selectedDifficultyAmmo, isSatellite: false,
                draw() {
                    if (!this.alive) return;

                    // Ground platform
                    ctx.fillStyle = '#556b2f'; // Dark olive green
                    ctx.fillRect(this.x, this.y + this.height * 0.8, this.width, this.height * 0.2);

                    // Central command building - made taller
                    const buildingWidth = this.width * 0.4;
                    const buildingX = this.x + (this.width - buildingWidth) / 2;
                    const buildingHeight = this.height * 0.8; // Increased from 0.7
                    const buildingY = this.y + this.height * 0.8 - buildingHeight;

                    // Main building
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(buildingX, buildingY, buildingWidth, buildingHeight);

                    // Building top
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(buildingX + buildingWidth * 0.1, buildingY, buildingWidth * 0.8, buildingHeight * 0.1);

                    // Building windows - adjusted for taller building
                    ctx.fillStyle = '#88ccff';
                    const windowSize = buildingWidth * 0.1;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) { // Added an extra row of windows
                            ctx.fillRect(
                                buildingX + buildingWidth * 0.2 + i * buildingWidth * 0.3,
                                buildingY + buildingHeight * 0.15 + j * buildingHeight * 0.25,
                                windowSize, windowSize
                            );
                        }
                    }

                    // Missile silos - adjusted positions
                    const siloWidth = this.width * 0.15;
                    const siloLeftX = this.x + this.width * 0.1;
                    const siloRightX = this.x + this.width * 0.75;
                    const siloY = this.y + this.height * 0.75;
                    const siloHeight = this.height * 0.4; // Increased from 0.35

                    // Silo bases
                    ctx.fillStyle = '#777777';
                    ctx.fillRect(siloLeftX, siloY - siloHeight * 0.2, siloWidth, siloHeight * 0.2);
                    ctx.fillRect(siloRightX, siloY - siloHeight * 0.2, siloWidth, siloHeight * 0.2);

                    // Draw missiles in silos - made taller
                    const missileWidth = siloWidth * 0.6;
                    const missileLeftX = siloLeftX + (siloWidth - missileWidth) / 2;
                    const missileRightX = siloRightX + (siloWidth - missileWidth) / 2;

                    // Draw left missile
                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(missileLeftX, siloY - siloHeight * 0.8, missileWidth, siloHeight * 0.6);

                    // Left missile tip
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.moveTo(missileLeftX, siloY - siloHeight * 0.8);
                    ctx.lineTo(missileLeftX + missileWidth / 2, siloY - siloHeight);
                    ctx.lineTo(missileLeftX + missileWidth, siloY - siloHeight * 0.8);
                    ctx.closePath();
                    ctx.fill();

                    // Draw right missile
                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(missileRightX, siloY - siloHeight * 0.7, missileWidth, siloHeight * 0.5);

                    // Right missile tip
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.moveTo(missileRightX, siloY - siloHeight * 0.7);
                    ctx.lineTo(missileRightX + missileWidth / 2, siloY - siloHeight * 0.9);
                    ctx.lineTo(missileRightX + missileWidth, siloY - siloHeight * 0.7);
                    ctx.closePath();
                    ctx.fill();

                    // Small antenna on command building
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(buildingX + buildingWidth / 2, buildingY);
                    ctx.lineTo(buildingX + buildingWidth / 2, buildingY - buildingHeight * 0.15);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(buildingX + buildingWidth / 2, buildingY - buildingHeight * 0.15, buildingWidth * 0.05, 0, Math.PI * 2);
                    ctx.stroke();

                    // Ammo display
                    ctx.fillStyle = '#ffffff';
                    const fontSize = Math.max(8, Math.min(12, Math.floor(this.width * 0.25)));
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.ammo, this.x + this.width / 2, this.y + this.height * 0.9);
                }
            };
        }
        function createSatelliteBase(xRatio, yRatio) {
            const satWidth = canvas.width * SATELLITE_WIDTH_RATIO;
            const satHeight = canvas.height * SATELLITE_HEIGHT_RATIO;
            const satX = (xRatio * canvas.width) - (satWidth / 2);
            const satY = yRatio * canvas.height;
            return {
                x: satX, y: satY, width: satWidth, height: satHeight, bodyColor: '#b0b0b0', panelColor: '#3333cc', panelHighlight: '#6666ff', outlineColor: '#777777', antennaColor: '#dddddd', lightColor: '#ff0000', alive: true, ammo: selectedDifficultyAmmo, isSatellite: true, shield: null,
                draw() {
                    if (!this.alive) return;

                    // Main satellite body (central platform)
                    const bodyW = this.width * 0.6;
                    const bodyH = this.height * 0.7;
                    const bodyX = this.x + (this.width - bodyW) / 2;
                    const bodyY = this.y + (this.height - bodyH) / 2;

                    // Central command module (matching the land base's command building)
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.moveTo(bodyX, bodyY + bodyH * 0.2);
                    ctx.lineTo(bodyX + bodyW * 0.1, bodyY);
                    ctx.lineTo(bodyX + bodyW * 0.9, bodyY);
                    ctx.lineTo(bodyX + bodyW, bodyY + bodyH * 0.2);
                    ctx.lineTo(bodyX + bodyW, bodyY + bodyH * 0.8);
                    ctx.lineTo(bodyX + bodyW * 0.9, bodyY + bodyH);
                    ctx.lineTo(bodyX + bodyW * 0.1, bodyY + bodyH);
                    ctx.lineTo(bodyX, bodyY + bodyH * 0.8);
                    ctx.closePath();
                    ctx.fill();

                    // Command module outline
                    ctx.strokeStyle = '#444444';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Solar panels - left and right (similar layout to the land base silos)
                    const panelW = this.width * 0.25;
                    const panelH = this.height * 0.8;
                    const panelY = this.y + (this.height - panelH) / 2;

                    // Left panel
                    ctx.fillStyle = '#336699'; // Blue panels (like windows in command center)
                    ctx.fillRect(this.x, panelY, panelW, panelH);

                    // Right panel
                    ctx.fillRect(this.x + this.width - panelW, panelY, panelW, panelH);

                    // Panel details - grid lines
                    ctx.strokeStyle = '#88ccff';
                    ctx.lineWidth = 1;

                    // Left panel grid
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, panelY + panelH * (i + 1) / 4);
                        ctx.lineTo(this.x + panelW, panelY + panelH * (i + 1) / 4);
                        ctx.stroke();
                    }
                    for (let i = 0; i < 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + panelW * (i + 1) / 2, panelY);
                        ctx.lineTo(this.x + panelW * (i + 1) / 2, panelY + panelH);
                        ctx.stroke();
                    }

                    // Right panel grid
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width - panelW, panelY + panelH * (i + 1) / 4);
                        ctx.lineTo(this.x + this.width, panelY + panelH * (i + 1) / 4);
                        ctx.stroke();
                    }
                    for (let i = 0; i < 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width - panelW * (i + 1) / 2, panelY);
                        ctx.lineTo(this.x + this.width - panelW * (i + 1) / 2, panelY + panelH);
                        ctx.stroke();
                    }

                    // Windows on command module (matching land base)
                    ctx.fillStyle = '#88ccff';
                    const windowSize = bodyW * 0.1;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 2; j++) {
                            ctx.fillRect(
                                bodyX + bodyW * 0.2 + i * bodyW * 0.3,
                                bodyY + bodyH * 0.25 + j * bodyH * 0.3,
                                windowSize, windowSize
                            );
                        }
                    }

                    // Missile launchers (top and bottom, similar to land base's dual launchers)
                    const launcherW = bodyW * 0.15;
                    const launcherH = this.height * 0.15;

                    // Top launcher
                    ctx.fillStyle = '#777777';
                    ctx.fillRect(bodyX + (bodyW - launcherW) / 2, bodyY - launcherH * 0.6, launcherW, launcherH * 0.6);

                    // Top missile
                    const missileW = launcherW * 0.6;
                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(bodyX + (bodyW - missileW) / 2, bodyY - launcherH * 1.5, missileW, launcherH * 0.9);

                    // Missile tip
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.moveTo(bodyX + (bodyW - missileW) / 2, bodyY - launcherH * 1.5);
                    ctx.lineTo(bodyX + bodyW / 2, bodyY - launcherH * 1.8);
                    ctx.lineTo(bodyX + (bodyW + missileW) / 2, bodyY - launcherH * 1.5);
                    ctx.closePath();
                    ctx.fill();

                    // Bottom launcher
                    ctx.fillStyle = '#777777';
                    ctx.fillRect(bodyX + (bodyW - launcherW) / 2, bodyY + bodyH, launcherW, launcherH * 0.6);

                    // Bottom missile
                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(bodyX + (bodyW - missileW) / 2, bodyY + bodyH + launcherH * 0.6, missileW, launcherH * 0.9);

                    // Bottom missile tip
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.moveTo(bodyX + (bodyW - missileW) / 2, bodyY + bodyH + launcherH * 1.5);
                    ctx.lineTo(bodyX + bodyW / 2, bodyY + bodyH + launcherH * 1.8);
                    ctx.lineTo(bodyX + (bodyW + missileW) / 2, bodyY + bodyH + launcherH * 1.5);
                    ctx.closePath();
                    ctx.fill();

                    // Communication antenna (matching land base)
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(bodyX + bodyW * 0.8, bodyY);
                    ctx.lineTo(bodyX + bodyW * 0.8, bodyY - bodyH * 0.3);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(bodyX + bodyW * 0.8, bodyY - bodyH * 0.3, bodyW * 0.05, 0, Math.PI * 2);
                    ctx.stroke();

                    // Status light
                    ctx.fillStyle = this.lightColor;
                    if (Math.floor(Date.now() / 500) % 2 === 0) {
                        ctx.beginPath();
                        ctx.arc(bodyX + bodyW * 0.2, bodyY + bodyH * 0.5, bodyW * 0.03, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Ammo display
                    ctx.fillStyle = '#ffff00';
                    const fontSize = Math.max(7, Math.min(10, Math.floor(this.width * 0.25)));
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(this.ammo, this.x + this.width / 2, this.y + this.height + 3);
                }
            };
        }
        function createIncomingMissile(config = {}) {
            const startX = config.startX !== undefined ? config.startX : Math.random() * canvas.width;
            const startY = config.startY !== undefined ? config.startY : 0;
            const target = config.target || getRandomTarget();
            let baseSpeed = MISSILE_SPEED_ENEMY_BASE + (currentWave * 0.08);
            baseSpeed = Math.min(baseSpeed, MAX_ENEMY_MISSILE_SPEED);
            const speed = config.speed || baseSpeed * (config.speedFactor || 1.0);
            const angle = Math.atan2(target.y - startY, target.x - startX);
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            const waveSmartBombChance = SMART_BOMB_CHANCE * (1 + currentWave * 0.05);
            const waveMIRVChance = MIRV_CHANCE * (1 + currentWave * 0.03);
            let isSmartBomb = config.isSmartBomb !== undefined ? config.isSmartBomb : (!config.isMIRV && !config.isSplit && Math.random() < waveSmartBombChance);
            let isMIRV = config.isMIRV !== undefined ? config.isMIRV : (!isSmartBomb && !config.isSplit && Math.random() < waveMIRVChance);
            let isSplit = config.isSplit || false;
            let color = '#ff0000'; let trailColor = 'rgba(255, 100, 100, 0.5)';
            if (isMIRV) { color = MIRV_WARHEAD_COLOR; trailColor = 'rgba(255, 150, 150, 0.5)'; }
            if (isSmartBomb) { color = SMART_BOMB_SPLIT_COLOR; trailColor = 'rgba(255, 200, 100, 0.5)'; }
            if (isSplit) { color = config.color || color; trailColor = config.trailColor || trailColor; }

            // Add the ignoreEnemyObjectsWhenExploding flag, default to false
            const ignoreEnemyObjectsWhenExploding = config.ignoreEnemyObjectsWhenExploding || false;

            return {
                x: startX, y: startY, targetX: target.x, targetY: target.y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, speed: speed, color: color, trailColor: trailColor, alive: true, trail: [{x: startX, y: startY}], isPlaneBomb: false, isSmartBomb: isSmartBomb, isMIRV: isMIRV, isSplit: isSplit, hasSplit: false, wavePartType: config.wavePartType, ignoreEnemyObjectsWhenExploding: ignoreEnemyObjectsWhenExploding,

                update() {
                    if (!this.alive) return;
                    this.x += this.dx; this.y += this.dy; this.trail.push({x: this.x, y: this.y}); if (this.trail.length > 15) { this.trail.shift(); }

                    if (this.isMIRV && !this.hasSplit && this.y >= MIRV_SPLIT_ALTITUDE) {
                        this.alive = false; this.hasSplit = true;
                        // Create an explosion that ignores enemy objects
                        createExplosion(this.x, this.y, EXPLOSION_RADIUS_START * 0.5, this.color, null, null, true);

                        for (let i = 0; i < MIRV_WARHEAD_COUNT; i++) {
                            // Use getBaseOrCityTarget for MIRV splits instead of getRandomTarget
                            const warheadTarget = getBaseOrCityTarget();
                            incomingMissiles.push(createIncomingMissile({
                                startX: this.x,
                                startY: this.y,
                                target: warheadTarget,
                                speed: this.speed * MIRV_WARHEAD_SPEED_FACTOR,
                                isSplit: true,
                                isMIRV: false,
                                isSmartBomb: false,
                                color: MIRV_WARHEAD_COLOR,
                                trailColor: 'rgba(255, 150, 150, 0.5)',
                                ignoreEnemyObjectsWhenExploding: true,
                                wavePartType: this.wavePartType
                            }));
                        }
                        return;
                    }

                    const splitAltitude = SMART_BOMB_SPLIT_ALTITUDE_MIN + Math.random() * (SMART_BOMB_SPLIT_ALTITUDE_MAX - SMART_BOMB_SPLIT_ALTITUDE_MIN);
                    if (this.isSmartBomb && !this.hasSplit && this.y >= splitAltitude) {
                        this.alive = false; this.hasSplit = true;
                        // Create an explosion that ignores enemy objects
                        createExplosion(this.x, this.y, EXPLOSION_RADIUS_START * 0.4, this.color, null, null, true);

                        for (let i = 0; i < SMART_BOMB_SPLIT_COUNT; i++) {
                            // Use getBaseOrCityTarget for smart bomb splits instead of getRandomTarget
                            const splitTarget = getBaseOrCityTarget();
                            incomingMissiles.push(createIncomingMissile({
                                startX: this.x,
                                startY: this.y,
                                target: splitTarget,
                                speed: this.speed * SMART_BOMB_SPLIT_SPEED_FACTOR,
                                isSplit: true,
                                isMIRV: false,
                                isSmartBomb: false,
                                color: SMART_BOMB_SPLIT_COLOR,
                                trailColor: 'rgba(255, 200, 100, 0.5)',
                                ignoreEnemyObjectsWhenExploding: true,
                                wavePartType: this.wavePartType
                            }));
                        }
                        return;
                    }

                    if (this.y >= this.targetY || this.y >= groundY) {
                        this.alive = false; const impactY = Math.min(this.targetY, groundY); const explosionSizeFactor = this.isSplit ? 0.6 : 1.0;
                        createExplosion(this.x, impactY, (EXPLOSION_RADIUS_MAX_BASE / 2) * explosionSizeFactor, this.color, null, null, this.ignoreEnemyObjectsWhenExploding);
                        checkObjectImpact(this.x, impactY, this.isPlaneBomb);
                    }
                },

                draw() {
                    if (!this.alive) return; ctx.strokeStyle = this.trailColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke();
                    const size = (this.isMIRV || this.isSmartBomb) && !this.hasSplit ? 5 : 4; ctx.fillStyle = this.color; ctx.fillRect(this.x - size/2, this.y - size/2, size, size); if ((this.isMIRV || this.isSmartBomb) && !this.hasSplit && Math.floor(Date.now() / 200) % 2 === 0) { ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fillRect(this.x - size/2 - 1, this.y - size/2 - 1, size + 2, size + 2); }
                }
            };
        }
        function createPlayerMissile(startX, startY, targetX, targetY) {
            const currentSpeed = getCurrentPlayerMissileSpeed(); const angle = Math.atan2(targetY - startY, targetX - startX); statsMissilesFired++;
            return {
                x: startX, y: startY, targetX: targetX, targetY: targetY, dx: Math.cos(angle) * currentSpeed, dy: Math.sin(angle) * currentSpeed, speed: currentSpeed, color: '#00ff00', trailColor: 'rgba(100, 255, 100, 0.5)', alive: true, trail: [{x: startX, y: startY}],
                update() {
                    if (!this.alive) return; this.x += this.dx; this.y += this.dy; this.trail.push({x: this.x, y: this.y}); if (this.trail.length > 10) { this.trail.shift(); } const distToTarget = distance(this.x, this.y, this.targetX, this.targetY); if (distToTarget < this.speed || (this.dx * (this.targetX - this.x) + this.dy * (this.targetY - this.y)) < 0) { this.alive = false; const currentExplosionRadius = getCurrentPlayerExplosionRadius(); createExplosion(this.targetX, this.targetY, EXPLOSION_RADIUS_START, this.color, currentExplosionRadius); }
                },
                draw() { if (!this.alive) return; ctx.strokeStyle = this.trailColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke(); ctx.fillStyle = this.color; ctx.fillRect(this.x - 1, this.y - 1, 3, 3); }
            };
        }
        function getBaseOrCityTarget() {
            const aliveCities = cities.filter(c => c.alive);
            const aliveBases = [...bases.filter(b => b.alive), ...satelliteBases.filter(s => s.alive)];
            let possibleTargets = [...aliveCities, ...aliveBases];
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);

            if (possibleTargets.length === 0) {
                // If no cities or bases are alive, target a random ground position
                let targetGroundX = canvas.width / 2 + (Math.random() - 0.5) * canvas.width * 0.4;
                return { x: targetGroundX, y: groundY };
            }

            // Select a random city or base
            const target = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
            return { x: target.x + (target.width / 2), y: target.y };
        }
        function createExplosion(x, y, startRadius, color, maxRadius = EXPLOSION_RADIUS_MAX_BASE, duration = EXPLOSION_DURATION, ignoreEnemyObjectsWhenExploding = false) {
            const effectiveMaxRadius = maxRadius || getCurrentPlayerExplosionRadius();
            if (typeof color !== 'string' || (!color.startsWith('#') && !color.startsWith('rgba'))) { color = '#888888'; }
            explosions.push({
                x: x, y: y, radius: startRadius, maxRadius: effectiveMaxRadius, duration: duration, currentFrame: 0, color: color, alive: true, collidedMissiles: new Set(), collidedBombs: new Set(), collidedPlanes: new Set(), ignoreEnemyObjectsWhenExploding: ignoreEnemyObjectsWhenExploding,
                update() { if (!this.alive) return; this.currentFrame++; const expansionPhase = this.duration * 0.6; if (this.currentFrame <= expansionPhase) { this.radius = startRadius + (this.maxRadius - startRadius) * (this.currentFrame / expansionPhase); } else { this.radius = this.maxRadius - (this.maxRadius * ((this.currentFrame - expansionPhase) / (this.duration - expansionPhase))); } this.radius = Math.max(0, this.radius); if (this.currentFrame >= this.duration) { this.alive = false; } if (this.currentFrame < expansionPhase) { checkExplosionCollisions(this); } },
                draw() { if (!this.alive) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); const intensity = Math.sin((this.currentFrame / this.duration) * Math.PI); let r = 180, g = 180, b = 180; try { if (this.color.startsWith('#') && this.color.length >= 7) { r = parseInt(this.color.slice(1, 3), 16); g = parseInt(this.color.slice(3, 5), 16); b = parseInt(this.color.slice(5, 7), 16); } else if (this.color.startsWith('rgba')) { const parts = this.color.match(/(\d+),\s*(\d+),\s*(\d+)/); if (parts) { r = parseInt(parts[1]); g = parseInt(parts[2]); b = parseInt(parts[3]); } } } catch (e) { console.warn("Could not parse explosion color:", this.color, e); r = 180; g = 180; b = 180; } ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + intensity * 0.6})`; ctx.fill(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.3 * intensity, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.8})`; ctx.fill(); }
            });
        }
        function createPlane() {
            const startY = PLANE_MIN_Y + Math.random() * (PLANE_MAX_Y - PLANE_MIN_Y); const bombsToDrop = BASE_BOMBS_PER_PLANE + Math.floor(currentWave / 3) * BOMBS_INCREASE_PER_WAVE; const isVariant = Math.random() < PLANE_VARIANT_CHANCE; const speedMultiplier = isVariant ? 1.4 : 1.0; const planeSpeed = (PLANE_SPEED_BASE + currentWave * PLANE_SPEED_INCREASE_PER_WAVE) * speedMultiplier; const bodyColor = isVariant ? '#A9A9A9' : '#B0C4DE'; const wingColor = isVariant ? '#696969' : '#778899';
            return {
                x: canvas.width + PLANE_WIDTH, y: startY, width: PLANE_WIDTH, height: PLANE_HEIGHT, speed: planeSpeed, alive: true, bombsLeft: bombsToDrop, bombDropTimer: PLANE_BOMB_DROP_INTERVAL_MIN + Math.random() * (PLANE_BOMB_DROP_INTERVAL_MAX - PLANE_BOMB_DROP_INTERVAL_MIN), bodyColor: bodyColor, wingColor: wingColor, tailColor: '#708090', cockpitColor: '#1E90FF', engineColor: '#555555', isVariant: isVariant, wavePartType: 'plane',
                update() { if (!this.alive) return; this.x -= this.speed; this.bombDropTimer--; if (this.bombDropTimer <= 0 && this.bombsLeft > 0) { this.dropBomb(); this.bombsLeft--; this.bombDropTimer = PLANE_BOMB_DROP_INTERVAL_MIN + Math.random() * (PLANE_BOMB_DROP_INTERVAL_MAX - PLANE_BOMB_DROP_INTERVAL_MIN); } if (this.x < -this.width * 1.5) { this.alive = false; } },
                dropBomb() { const bombStartX = this.x + this.width / 2; const bombStartY = this.y + this.height * 0.7; planeBombs.push(createBomb(bombStartX, bombStartY)); },
                draw() { if (!this.alive) return; const w = this.width; const h = this.height; const x = this.x; const y = this.y; ctx.save(); ctx.translate(x, y); ctx.fillStyle = this.bodyColor; ctx.beginPath(); ctx.moveTo(w * 0.1, h * 0.3); ctx.lineTo(w * 0.85, h * 0.15); ctx.quadraticCurveTo(w, h * 0.5, w * 0.85, h * 0.85); ctx.lineTo(w * 0.1, h * 0.7); ctx.quadraticCurveTo(0, h * 0.5, w * 0.1, h * 0.3); ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#666'; ctx.lineWidth = 1; ctx.stroke(); ctx.fillStyle = this.cockpitColor; ctx.beginPath(); ctx.moveTo(w * 0.7, h * 0.25); ctx.lineTo(w * 0.9, h * 0.4); ctx.lineTo(w * 0.9, h * 0.6); ctx.lineTo(w * 0.7, h * 0.75); ctx.closePath(); ctx.fill(); ctx.fillStyle = this.wingColor; ctx.beginPath(); ctx.moveTo(w * 0.3, h * 0.3); ctx.lineTo(w * 0.6, h * -0.1); ctx.lineTo(w * 0.7, h * 0.1); ctx.lineTo(w * 0.45, h * 0.4); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(w * 0.3, h * 0.7); ctx.lineTo(w * 0.6, h * 1.1); ctx.lineTo(w * 0.7, h * 0.9); ctx.lineTo(w * 0.45, h * 0.6); ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#555'; ctx.stroke(); ctx.fillStyle = this.tailColor; ctx.beginPath(); ctx.moveTo(w * 0.05, h * 0.3); ctx.lineTo(w * 0.2, h * -0.1); ctx.lineTo(w * 0.25, h * 0.1); ctx.lineTo(w * 0.1, h * 0.4); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = this.wingColor; ctx.beginPath(); ctx.moveTo(w * 0.05, h * 0.3); ctx.lineTo(w * 0.2, h * 0.1); ctx.lineTo(w * 0.25, h * 0.2); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(w * 0.05, h * 0.7); ctx.lineTo(w * 0.2, h * 0.9); ctx.lineTo(w * 0.25, h * 0.8); ctx.closePath(); ctx.fill(); ctx.fillStyle = this.engineColor; ctx.fillRect(w * 0.4, h * 0.6, w * 0.25, h * 0.3); ctx.fillRect(w * 0.4, h * 0.1, w * 0.25, h * 0.3); ctx.restore(); }
            };
        }
        function createBomb(startX, startY) {
            const target = getRandomTarget(); const angle = Math.atan2(target.y - startY, target.x - startX); const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO); const speed = PLANE_BOMB_SPEED + (currentWave * 0.03);
            return {
                x: startX, y: startY, targetX: target.x, targetY: target.y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, color: PLANE_BOMB_COLOR, trailColor: PLANE_BOMB_TRAIL_COLOR, alive: true, trail: [{x: startX, y: startY}], isPlaneBomb: true,
                update() { if (!this.alive) return; this.x += this.dx; this.y += this.dy; this.trail.push({x: this.x, y: this.y}); if (this.trail.length > 12) { this.trail.shift(); } if (this.y >= this.targetY || this.y >= groundY) { this.alive = false; const impactY = Math.min(this.targetY, groundY); createExplosion(this.x, impactY, EXPLOSION_RADIUS_START * 0.8, this.color, EXPLOSION_RADIUS_MAX_BASE * 0.6); checkObjectImpact(this.x, impactY, this.isPlaneBomb); } },
                draw() { if (!this.alive) return; ctx.strokeStyle = this.trailColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke(); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); ctx.fill(); }
            };
        }

        // --- Collision Detection ---
        function checkExplosionCollisions(explosion) {
            let explosionMadeKill = false;

            // Only check collisions with enemy missiles/planes/bombs if ignoreEnemyObjectsWhenExploding is false
            if (!explosion.ignoreEnemyObjectsWhenExploding) {
                incomingMissiles.forEach((missile, index) => { if (missile.alive && !explosion.collidedMissiles.has(index)) { const dist = distance(explosion.x, explosion.y, missile.x, missile.y); if (dist < explosion.radius) { missile.alive = false; explosion.collidedMissiles.add(index); explosionMadeKill = true; statsEnemyMissilesDestroyed++; let pointsToAdd = POINTS_PER_MISSILE; if (explosion.color === '#00ff00' && dist < ACCURACY_BONUS_THRESHOLD) { pointsToAdd += ACCURACY_BONUS_POINTS; statsAccuracyBonusHits++; messageBonusText.textContent = `ACCURACY BONUS +$${Math.round(ACCURACY_BONUS_POINTS * scoreMultiplier * difficultyScoreMultiplier)}!`; accuracyBonusMessageTimer = 120; } const finalPoints = Math.round(pointsToAdd * scoreMultiplier * difficultyScoreMultiplier); score += finalPoints; gameTotalScore += finalPoints; createExplosion(missile.x, missile.y, EXPLOSION_RADIUS_START, missile.color); } } });

                planes.forEach((plane, index) => { if (plane.alive && !explosion.collidedPlanes.has(index)) { if (explosion.x + explosion.radius > plane.x && explosion.x - explosion.radius < plane.x + plane.width && explosion.y + explosion.radius > plane.y && explosion.y - explosion.radius < plane.y + plane.height) { plane.alive = false; explosion.collidedPlanes.add(index); explosionMadeKill = true; statsPlanesDestroyed++; const finalPoints = Math.round(PLANE_BONUS_SCORE * scoreMultiplier * difficultyScoreMultiplier); score += finalPoints; gameTotalScore += finalPoints; createExplosion(plane.x + plane.width / 2, plane.y + plane.height / 2, EXPLOSION_RADIUS_START * 1.5, plane.bodyColor, EXPLOSION_RADIUS_MAX_BASE * 1.2, EXPLOSION_DURATION * 1.2); } } });

                planeBombs.forEach((bomb, index) => { if (bomb.alive && !explosion.collidedBombs.has(index)) { const dist = distance(explosion.x, explosion.y, bomb.x, bomb.y); if (dist < explosion.radius) { bomb.alive = false; explosion.collidedBombs.add(index); explosionMadeKill = true; statsPlaneBombsDestroyed++; const finalPoints = Math.round(PLANE_BOMB_POINTS * scoreMultiplier * difficultyScoreMultiplier); score += finalPoints; gameTotalScore += finalPoints; createExplosion(bomb.x, bomb.y, EXPLOSION_RADIUS_START * 0.8, bomb.color); } } });
            }

            if (explosionMadeKill && explosion.color === '#00ff00') { consecutiveIntercepts++; scoreMultiplier = Math.min(MULTIPLIER_MAX, 1.0 + Math.floor(consecutiveIntercepts / MULTIPLIER_INCREASE_INTERVAL)); updateUI(); }
        }
        function checkObjectImpact(impactX, impactY, isBomb = false) {
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO); const cityHeight = canvas.height * CITY_HEIGHT_RATIO; const baseHeight = canvas.height * BASE_HEIGHT_RATIO; let hitOccurred = false;
            for (let i = 0; i < baseShields.length; i++) { const shield = baseShields[i]; if (shield && shield.alive) { const base = bases[i]; const shieldCenterX = base.x + base.width / 2; const shieldRadius = BASE_SHIELD_RADIUS_MULTIPLIER * ((base.width / 2) + (canvas.width * CITY_WIDTH_RATIO / 2) + 5); const shieldBottomEdgeY = base.y - 15; const shieldApexY = shieldBottomEdgeY - shieldRadius * 0.3; const startX = shieldCenterX - shieldRadius; const endX = shieldCenterX + shieldRadius; const shieldWidth = endX - startX; if (impactX >= startX && impactX <= endX) { let y_on_curve; if (shieldWidth > 0) { const t = (impactX - startX) / shieldWidth; const one_minus_t = 1 - t; y_on_curve = (one_minus_t * one_minus_t * shieldBottomEdgeY) + (2 * one_minus_t * t * shieldApexY) + (t * t * shieldBottomEdgeY); } else { y_on_curve = shieldBottomEdgeY; } if (impactY >= y_on_curve) { shield.strength -= SHIELD_DAMAGE_PER_HIT; shield.flashTimer = SHIELD_FLASH_DURATION; if (shield.strength <= 0) { shield.alive = false; createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 1.5, '#ffffff'); } else { createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 0.5, SHIELD_FLASH_COLOR); } return; } } } }
            for (let i = 0; i < satelliteBases.length; i++) { const sat = satelliteBases[i]; if (sat.alive && sat.shield && sat.shield.alive) { const shieldCenterX = sat.x + sat.width / 2; const shieldCenterY = sat.y + sat.height / 2; const shieldRadiusX = sat.width * 0.6 + 4; const shieldRadiusY = sat.height * 0.8 + 4; const dx = impactX - shieldCenterX; const dy = impactY - shieldCenterY; if (((dx * dx) / (shieldRadiusX * shieldRadiusX)) + ((dy * dy) / (shieldRadiusY * shieldRadiusY)) <= 1) { sat.shield.strength -= SHIELD_DAMAGE_PER_HIT; sat.shield.flashTimer = SHIELD_FLASH_DURATION; if (sat.shield.strength <= 0) { sat.shield.alive = false; createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 1.2, '#eeeeee'); } else { createExplosion(impactX, impactY, EXPLOSION_RADIUS_START * 0.5, SHIELD_FLASH_COLOR); } return; } } }
            satelliteBases.forEach(sat => { if (sat.alive && impactX >= sat.x && impactX <= sat.x + sat.width && impactY >= sat.y && impactY <= sat.y + sat.height) { sat.alive = false; hitOccurred = true; createExplosion(impactX, impactY, EXPLOSION_RADIUS_START, sat.outlineColor); } });
            if (impactY >= groundY - cityHeight && impactY < groundY) { cities.forEach(city => { if (city.alive && impactX >= city.x && impactX <= city.x + city.width) { city.alive = false; hitOccurred = true; statsCitiesLost++; } }); }
            if (impactY >= groundY - baseHeight && impactY < groundY) { bases.forEach(base => { if (base.alive && impactX >= base.x && impactX <= base.x + base.width) { base.alive = false; hitOccurred = true; statsBasesLost++; } }); }
            if (hitOccurred) { consecutiveIntercepts = 0; scoreMultiplier = 1.0; updateUI(); }
        }

        // --- Wave System Logic ---
        function defineWaves() {
             return [
                 [{ type: 'missile', count: 16, speedFactor: 1.1 }, { type: 'plane', count: 1 }], // Wave 1
                 [{ type: 'missile', count: 22, speedFactor: 1.15 }, { type: 'plane', count: 1 }], // Wave 2
                 [{ type: 'missile', count: 26, speedFactor: 1.2 }, { type: 'plane', count: 2, variantChance: 0.1 }], // Wave 3
                 [{ type: 'missile', count: 21, speedFactor: 1.25 }, { type: 'plane', count: 4, variantChance: 0.2 }, { type: 'smart_bomb', count: 6, speedFactor: 1.0 }], // Wave 4
                 [{ type: 'missile', count: 21, speedFactor: 1.25 }, { type: 'plane', count: 6, variantChance: 0.2 }, { type: 'smart_bomb', count: 8, speedFactor: 1.1 }], // Wave 5
                 [{ type: 'missile', count: 24, speedFactor: 1.35 }, { type: 'plane', count: 8, variantChance: 0.2 }, { type: 'mirv', count: 8, speedFactor: 1.0 }], // Wave 6
                 [{ type: 'missile', count: 24, speedFactor: 1.40 }, { type: 'smart_bomb', count: 8, speedFactor: 1.15 }, { type: 'plane', count: 10, variantChance: 0.35, speedFactor: 1.1 }], // Wave 7
                 [{ type: 'missile', count: 28, speedFactor: 1.45 }, { type: 'mirv', count: 18, speedFactor: 1.15 }, { type: 'smart_bomb', count: 8, speedFactor: 1.2 }], // Wave 8
                 [{ type: 'missile', count: 28, speedFactor: 1.5 }, { type: 'smart_bomb', count: 8, speedFactor: 1.35 }, { type: 'mirv', count: 5, speedFactor: 1.25 }, { type: 'plane', count: 8, variantChance: 0.5, speedFactor: 1.2 }], // Wave 9
                 [{ type: 'missile', count: 32, speedFactor: 1.6 }, { type: 'smart_bomb', count: 8, speedFactor: 1.5 }, { type: 'mirv', count: 7, speedFactor: 1.4 }, { type: 'plane', count: 12, variantChance: 0.6, speedFactor: 1.3 }], // Wave 10
                 [{ type: 'missile', count: 36, speedFactor: 1.7 }, { type: 'smart_bomb', count: 8, speedFactor: 1.6 }, { type: 'mirv', count: 8, speedFactor: 1.5 }, { type: 'plane', count: 12, variantChance: 0.7, speedFactor: 1.4 }], // Wave 11
             ];
        }
        function initWave(waveIndex) {
            try {
                console.log(`initWave: Entered for wave ${waveIndex}`);
                currentWave = waveIndex;
                waveTimer = 0; // Reset wave timer

                const effectiveWaveIndex = Math.min(waveIndex, waveDefinitions.length - 1);
                if (!waveDefinitions || waveDefinitions.length === 0) {
                    throw new Error("waveDefinitions is empty or not defined.");
                }

                if (effectiveWaveIndex < 0 || effectiveWaveIndex >= waveDefinitions.length) {
                    throw new Error(`Calculated effectiveWaveIndex (${effectiveWaveIndex}) is out of bounds for waveDefinitions (length ${waveDefinitions.length}).`);
                }

                currentWaveConfig = JSON.parse(JSON.stringify(waveDefinitions[effectiveWaveIndex]));
                console.log(`initWave: Loaded config for wave ${waveIndex} (using definition ${effectiveWaveIndex}):`, JSON.stringify(currentWaveConfig));

                if (!Array.isArray(currentWaveConfig)) {
                    throw new Error(`currentWaveConfig for wave ${waveIndex} (effective index ${effectiveWaveIndex}) is not an array.`);
                }

                if (waveIndex >= waveDefinitions.length) {
                    // Cap the scaling factor for very high waves
                    const baseScalingIncrease = 0.06;
                    const maxScalingFactor = 4.0;

                    // Calculate scaling with a cap
                    const scalingFactor = Math.min(
                        maxScalingFactor,
                        1 + (waveIndex - (waveDefinitions.length - 1)) * baseScalingIncrease
                    );

                    console.log(`Wave ${waveIndex} using scaling factor: ${scalingFactor}`);

                    currentWaveConfig.forEach(part => {
                        part.count = Math.ceil(part.count * scalingFactor);
                        if (part.speedFactor) {
                            part.speedFactor = Math.min(3.0, part.speedFactor * scalingFactor);
                        }
                    });

                    console.log(`initWave: Scaled config for high wave ${waveIndex}:`, JSON.stringify(currentWaveConfig));
                }

                // Clear game objects
                incomingMissiles = [];
                playerMissiles = [];
                explosions = [];
                activeSonicWave = null;
                planes = [];
                planeBombs = [];
                waveEnemiesSpawned = 0;

                console.log(`initWave: Calculating waveEnemiesRequired for wave ${waveIndex}...`);

                // Calculate with better error handling
                waveEnemiesRequired = 0;
                currentWaveConfig.forEach(part => {
                    if (typeof part === 'object' && part !== null && typeof part.count === 'number') {
                        waveEnemiesRequired += part.count;
                    } else {
                        console.warn(`Skipping invalid part in wave config ${waveIndex}:`, part);
                    }
                });

                // Ensure we have at least some enemies
                if (waveEnemiesRequired <= 0) {
                    console.warn(`Warning: waveEnemiesRequired calculated as ${waveEnemiesRequired}, setting to default 20`);
                    waveEnemiesRequired = 20;
                }

                console.log(`initWave: waveEnemiesRequired = ${waveEnemiesRequired}`);

                // Refresh base ammo
                bases.forEach(b => { if (b.alive) b.ammo = selectedDifficultyAmmo; });
                satelliteBases.forEach(s => { if (s.alive) s.ammo = selectedDifficultyAmmo; });

                updateUI();
                updateSpecialWeaponsUI();

                console.log(`initWave: Exiting for wave ${waveIndex}`);
            } catch (error) {
                console.error(`Error during initWave(${waveIndex}):`, error);
                showMessage("WAVE INIT ERROR", `Failed to initialize wave ${waveIndex + 1}: ${error.message}`, "Check console for details.");
                isGameOver = true;
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
            }
        }
        function spawnEnemiesForWave() {
            if (transitioningWave || isGameOver || isPaused || waveEnemiesSpawned >= waveEnemiesRequired) return;

            const potentialSpawns = [];
            currentWaveConfig.forEach(part => {
                const requiredForThisPart = part.count || 0;
                const currentSpawnedForThisPart = (part.type === 'plane' ? planes : incomingMissiles).filter(e => e.wavePartType === part.type).length;
                if (currentSpawnedForThisPart < requiredForThisPart) {
                    // Cap the spawn rate multiplier to prevent excessively high spawn chances
                    const spawnRateMultiplier = Math.min(5.0, 1 + currentWave * 0.15);
                    let baseSpawnChance = 0.025;
                    if (part.type === 'plane') { baseSpawnChance = PLANE_SPAWN_CHANCE; }

                    // Cap the speed factor to prevent excessively fast enemies
                    const safeFactor = Math.min(3.0, part.speedFactor || 1.0);

                    // Cap the final spawn chance to prevent issues
                    let spawnChance = Math.min(0.75, baseSpawnChance * spawnRateMultiplier * safeFactor);

                    potentialSpawns.push({ partConfig: part, spawnChance: spawnChance });
                }
            });

            if (potentialSpawns.length > 0) {
                 const randomIndex = Math.floor(Math.random() * potentialSpawns.length);
                 const selectedSpawn = potentialSpawns[randomIndex];
                 const part = selectedSpawn.partConfig;
                if (Math.random() < selectedSpawn.spawnChance) {
                    if (part.type === 'missile' || part.type === 'smart_bomb' || part.type === 'mirv') {
                        let missileType = part.type;
                        let baseSpeed = MISSILE_SPEED_ENEMY_BASE + (currentWave * 0.08);
                        baseSpeed = Math.min(baseSpeed, MAX_ENEMY_MISSILE_SPEED);
                        let config = {
                            speed: baseSpeed * Math.min(3.0, part.speedFactor || 1.0),
                            isSmartBomb: missileType === 'smart_bomb',
                            isMIRV: missileType === 'mirv',
                            wavePartType: part.type
                        };
                        incomingMissiles.push(createIncomingMissile(config));
                        waveEnemiesSpawned++;
                    } else if (part.type === 'plane') {
                        const newPlane = createPlane();
                        newPlane.wavePartType = part.type;
                        planes.push(newPlane);
                        waveEnemiesSpawned++;
                    }
                }
            }

            // Force wave completion when we've spawned enough enemies
            // This is an additional safeguard
            if (waveEnemiesSpawned >= waveEnemiesRequired) {
                console.log(`All required enemies (${waveEnemiesRequired}) spawned for wave ${currentWave + 1}`);
            }
        }
        function checkWaveEnd() {
            if (transitioningWave || isGameOver || isPaused) return;

            // Add debug logging for high wave numbers
            if (currentWave >= 30) {
                console.log(`Wave ${currentWave + 1} check - Spawned: ${waveEnemiesSpawned}, Required: ${waveEnemiesRequired}`);
                console.log(`Enemies remaining - Missiles: ${incomingMissiles.filter(m => m.alive).length}, Planes: ${planes.filter(p => p.alive).length}, Bombs: ${planeBombs.filter(b => b.alive).length}`);
            }

            // Check if all active enemies are gone
            const allEnemiesGone = incomingMissiles.every(m => !m.alive) &&
                                  planes.every(p => !p.alive) &&
                                  planeBombs.every(b => !b.alive);

            // Check if all explosions are done
            const allExplosionsDone = explosions.every(e => !e.alive);

            // Check if we've spawned all required enemies
            // Add safeguard for cases where waveEnemiesRequired might be invalid
            const allEnemiesSpawned = waveEnemiesRequired > 0 ?
                                     waveEnemiesSpawned >= waveEnemiesRequired :
                                     waveTimer > 600; // Fallback timer (10 seconds)

            // Wave is complete when all conditions are met
            const waveComplete = allEnemiesSpawned && allEnemiesGone && allExplosionsDone && !activeSonicWave;

            if (waveComplete) {
                console.log(`Wave ${currentWave + 1} completed successfully!`);
                transitioningWave = true;
                nextWave();
            } else if (currentWave >= 30 && waveTimer > 3600) {
                // Safety valve - if a high wave has been running for 60 seconds (3600 frames at 60fps),
                // force completion even if normal conditions aren't met
                console.log(`Wave ${currentWave + 1} force-completed due to timeout!`);
                transitioningWave = true;
                nextWave();
            }
        }

        // --- Game Flow ---
        function startGame() {
            try {
                console.log("startGame: Entered"); if (!difficultySelected) { console.warn("Difficulty not selected!"); return; } console.log("startGame: Difficulty selected, proceeding...");
                score = 0; gameTotalScore = 0; currentWave = -1; isGameOver = false; isPaused = false; transitioningWave = false; gameHasStarted = true; bonusMissileCount = 0;
                storeStockSatellite = MAX_STOCK_SATELLITE; storeStockBase = MAX_STOCK_BASE; storeStockCity = MAX_STOCK_CITY; storeStockShield = MAX_STOCK_SHIELD; storeStockSatShield = MAX_STOCK_SAT_SHIELD; storeStockSonicWave = MAX_STOCK_SONIC_WAVE; storeStockBomb = MAX_STOCK_BOMB;
                inventorySonicWave = 0; inventoryBomb = 0; isBombArmed = false; activeSonicWave = null; satelliteBases = []; baseShields = [null, null, null]; planes = []; planeBombs = []; incomingMissiles = []; playerMissiles = []; explosions = []; statsMissilesFired = 0; statsEnemyMissilesDestroyed = 0; statsPlaneBombsDestroyed = 0; statsPlanesDestroyed = 0; statsCitiesLost = 0; statsBasesLost = 0; statsAccuracyBonusHits = 0; playerMissileSpeedLevel = 0; explosionRadiusLevel = 0; consecutiveIntercepts = 0; scoreMultiplier = 1.0; highScore = parseInt(localStorage.getItem('missileCommandHighScore') || '0'); console.log("startGame: State variables reset");
                console.log("startGame: Setting up UI..."); startMenuContainer.style.display = 'none'; canvasContainer.style.display = 'block'; canvas.style.display = 'block'; uiContainer.style.display = 'flex'; controlsContainer.style.display = 'flex'; specialWeaponsUIDiv.style.display = 'flex'; screenshotButton.style.display = 'inline-block'; hideMessage(); statsContainer.style.display = 'none'; pauseOverlay.style.display = 'none'; canvas.style.cursor = 'crosshair'; console.log("startGame: UI setup complete");
                console.log("startGame: Initializing game objects..."); cities = []; const cityWidth = canvas.width * CITY_WIDTH_RATIO; const citySpacingRatio = (INTERNAL_WIDTH - 6 * (INTERNAL_WIDTH * CITY_WIDTH_RATIO)) / (7 * INTERNAL_WIDTH); const cityWidthRatio = CITY_WIDTH_RATIO; for (let i = 0; i < 3; i++) cities.push(createCity(citySpacingRatio * (i + 1) + cityWidthRatio * i)); for (let i = 0; i < 3; i++) cities.push(createCity(citySpacingRatio * (i + 4) + cityWidthRatio * (i + 3))); cities.forEach(c => c.alive = true); bases = []; const basePositionsRatios = [0.15, 0.5, 0.85]; bases.push(createBase(basePositionsRatios[0])); bases.push(createBase(basePositionsRatios[1])); bases.push(createBase(basePositionsRatios[2])); bases.forEach(b => b.alive = true); console.log("startGame: Game objects initialized");
                console.log("startGame: Calling initWave(0)..."); initWave(0); console.log("startGame: initWave(0) complete");
                restartButton.style.display = 'inline-block'; pauseButton.style.display = 'inline-block'; pauseButton.textContent = 'Pause'; pauseButton.disabled = false;
                if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } console.log("startGame: Calling gameLoop()..."); gameLoop(); console.log("startGame: Exiting");
            } catch (error) { console.error("Error during startGame:", error); showMessage("STARTUP ERROR", `Failed to start game: ${error.message}`, "Check console for details."); isGameOver = true; }
        }
        function nextWave() {
            let bonusEarned = calculateBonus();
            score += Math.round(bonusEarned * difficultyScoreMultiplier);
            gameTotalScore += Math.round(bonusEarned * difficultyScoreMultiplier);
            updateUI();
            const citiesSurvived = cities.filter(c => c.alive).length;
            const citiesLost = 6 - citiesSurvived;
            let bonusChangeMsg = "";
            if (citiesLost > 0) {
                const lostBonus = Math.min(bonusMissileCount, citiesLost);
                if (lostBonus > 0) { bonusChangeMsg = `Lost ${lostBonus} bonus missile${lostBonus > 1 ? 's' : ''}!`; bonusMissileCount -= lostBonus; }
            } else { bonusMissileCount++; bonusChangeMsg = `PERFECT! +1 Bonus Missile!`; }
            bonusMissileCount = Math.max(0, bonusMissileCount);
            if (bonusMissileCount > 0) { bonusChangeMsg += ` (Total +${bonusMissileCount} active next wave)`; }
            else if (bonusChangeMsg !== "" && citiesLost > 0) { bonusChangeMsg += ` (Bonus Fire deactivated)`; }
            else if (bonusChangeMsg === "" && citiesLost > 0){ bonusChangeMsg = ""; }
            isBombArmed = false; canvas.style.cursor = 'crosshair'; bombControl.classList.remove('armed');
            showMessage(`WAVE ${currentWave + 1} CLEARED`, `Score Bonus: $${Math.round(bonusEarned * difficultyScoreMultiplier)}`, "", bonusChangeMsg);
            goToStoreButton.style.display = 'inline-block'; skipStoreButton.style.display = 'inline-block'; pauseButton.disabled = true; statsContainer.style.display = 'none'; updateUI();
        }
        function proceedToNextWave() { storeModal.style.display = 'none'; hideMessage(); initWave(currentWave + 1); transitioningWave = false; pauseButton.disabled = false; if (!isPaused && !gameLoopId) { gameLoop(); } }
        function calculateBonus() { let bonus = 0; cities.forEach(city => { if (city.alive) bonus += POINTS_PER_CITY; }); bases.forEach(base => { if (base.alive) bonus += base.ammo * POINTS_PER_AMMO; }); satelliteBases.forEach(sat => { if (sat.alive) bonus += sat.ammo * POINTS_PER_AMMO; }); return bonus; }
        function checkGameOverConditions() { if (isGameOver || !gameHasStarted) return; const basesRemaining = bases.filter(b => b.alive).length; const citiesRemaining = cities.filter(c => c.alive).length; const satellitesRemaining = satelliteBases.filter(s => s.alive).length; if (citiesRemaining === 0 || (basesRemaining === 0 && satellitesRemaining === 0)) { gameOver(); } }

        // --- MODIFIED: gameOver Function (Incorporates submission UI) ---
        function gameOver() {
            if (isGameOver) return; // Prevent running multiple times
            isGameOver = true; gameHasStarted = false; transitioningWave = false; isPaused = false; bonusMissileCount = 0; baseShields = [null, null, null]; isBombArmed = false; activeSonicWave = null; canvas.style.cursor = 'crosshair'; planes = []; planeBombs = [];
            let newHighScore = false;
            // Use gameTotalScore for high score comparison and storage
            if (gameTotalScore > highScore) {
                 highScore = gameTotalScore;
                 localStorage.setItem('missileCommandHighScore', highScore.toString());
                 newHighScore = true;
            }
            const basesRemaining = bases.filter(b => b.alive).length;
            const citiesRemaining = cities.filter(c => c.alive).length;
            const satellitesRemaining = satelliteBases.filter(s => s.alive).length;
            let reason = "";
            if (citiesRemaining === 0) { reason = "All cities destroyed!"; }
            else if (basesRemaining === 0 && satellitesRemaining === 0) { reason = "All launch sites destroyed!"; }
            else { reason = "Targets eliminated!"; }
            const accuracy = statsMissilesFired > 0 ? ((statsEnemyMissilesDestroyed + statsPlaneBombsDestroyed) / statsMissilesFired * 100).toFixed(1) : "N/A";

            statsContainer.innerHTML = ''; // Clear existing content
            // Generate stats array
            const stats = [
                `Wave Reached: ${currentWave + 1}`,
                `Accuracy Bonuses: ${statsAccuracyBonusHits}`,
                `Difficulty: ${selectedDifficultyName || 'N/A'}`,
                `Planes Down: ${statsPlanesDestroyed}`,
                `Missiles Fired: ${statsMissilesFired}`,
                `Cities Lost: ${statsCitiesLost}`,
                `Accuracy: ${accuracy}%`,
                `Bases Lost: ${statsBasesLost}`,
                `Enemy Missiles Down: ${statsEnemyMissilesDestroyed}`,
                `Final Score: $${gameTotalScore}`, // Use gameTotalScore
                `Plane Bombs Down: ${statsPlaneBombsDestroyed}`,
                newHighScore ? `NEW HIGH SCORE!` : `High Score: $${highScore}`
            ];
            stats.forEach(statText => { const span = document.createElement('span'); span.textContent = statText; statsContainer.appendChild(span); });

            const title = newHighScore ? "GAME OVER - NEW HIGH SCORE!" : "GAME OVER";
            showMessage(title, `Total Score: $${gameTotalScore}`, reason); // Use gameTotalScore
            messageBonusText.textContent = "";
            statsContainer.style.display = 'grid';
            goToStoreButton.style.display = 'none'; skipStoreButton.style.display = 'none';

            // Show Score Submission if score > 0
            if (gameTotalScore > 0) {
                scoreSubmissionDiv.style.display = 'flex'; // Show the submission section
                // playerNameInput.value = localStorage.getItem('lastPlayerName') || ''; // Pre-fill last name
                playerNameInput.value = 'ACE';
                submissionStatus.textContent = ''; // Clear previous status
                submitScoreButton.disabled = false; // Ensure button is enabled
                playerNameInput.focus(); // Focus the input field
            } else {
                 scoreSubmissionDiv.style.display = 'none'; // Hide if score is 0
            }

            // Ensure restart button is visible in the message box buttons area
            // Note: It's already inside .messageBoxButtons in the HTML
            restartButton.style.display = 'inline-block';
            pauseButton.style.display = 'inline-block'; pauseButton.textContent = 'Pause'; pauseButton.disabled = true;
            pauseOverlay.style.display = 'none'; bonusIndicator.style.display = 'none'; storeModal.style.display = 'none'; specialWeaponsUIDiv.style.display = 'none';

            // Stop game loop if running
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
        }

        // --- Pause/Resume Logic ---
        function pauseGame() { if (isGameOver || transitioningWave || !gameHasStarted || storeModal.style.display === 'block' || messageBox.style.display === 'block') return; isPaused = true; pauseOverlay.style.display = 'flex'; pauseButton.textContent = 'Resume'; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } }
        function resumeGame() { if (isGameOver || transitioningWave || !isPaused) return; isPaused = false; pauseOverlay.style.display = 'none'; pauseButton.textContent = 'Pause'; if (!gameLoopId) { gameLoop(); } }
        function togglePause() { if (isPaused) { resumeGame(); } else { pauseGame(); } isBombArmed = false; canvas.style.cursor = 'crosshair'; bombControl.classList.remove('armed'); updateSpecialWeaponsUI(); }

        // --- Screenshot Logic ---
        async function saveScreenshot() {
            console.log("Attempting to save screenshot...");
            const originalText = screenshotButton.textContent;
            screenshotButton.textContent = 'Saving...';
            screenshotButton.disabled = true;
            try {
                // Create a temporary canvas to draw everything onto
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw the game canvas content
                tempCtx.drawImage(canvas, 0, 0);

                // If game over message is visible, draw it too (simplified)
                if (messageBox.style.display === 'block' && isGameOver) {
                    console.warn("Screenshotting the message box overlay is complex and not fully implemented. Capturing game canvas only.");
                }

                // Convert canvas to Blob
                tempCanvas.toBlob(async (blob) => {
                    if (!blob) {
                        throw new Error("Canvas toBlob failed.");
                    }
                    try {
                         // Use Clipboard API to copy the image
                         await navigator.clipboard.write([
                             new ClipboardItem({ 'image/png': blob })
                         ]);
                         console.log("Screenshot copied to clipboard.");
                         screenshotButton.textContent = 'Copied!';
                    } catch (clipErr) {
                         console.error("Clipboard API failed, falling back to download:", clipErr);
                         // Fallback: Create a download link
                         const url = URL.createObjectURL(blob);
                         const a = document.createElement('a');
                         a.href = url;
                         a.download = `missile_command_screenshot_${Date.now()}.png`;
                         document.body.appendChild(a);
                         a.click();
                         document.body.removeChild(a);
                         URL.revokeObjectURL(url);
                         console.log("Screenshot download initiated.");
                         screenshotButton.textContent = 'Saved!';
                    } finally {
                        setTimeout(() => {
                            screenshotButton.textContent = "Save Screenshot";
                            screenshotButton.disabled = false;
                        }, 1500);
                    }
                }, 'image/png');

            } catch (err) {
                console.error("Screenshot failed:", err);
                screenshotButton.textContent = 'Error!';
                setTimeout(() => {
                    screenshotButton.textContent = "Save Screenshot";
                    screenshotButton.disabled = false;
                }, 2000);
            }
        }

        // --- Message Display ---
        function showMessage(title, textHTML, subtextHTML = "", bonusAlert = "") { messageTitle.textContent = title; messageText.innerHTML = textHTML; messageSubText.style.display = subtextHTML ? 'block' : 'none'; messageSubText.innerHTML = subtextHTML; messageBonusText.textContent = bonusAlert; messageBonusText.style.display = bonusAlert ? 'block' : 'none'; goToStoreButton.style.display = 'none'; skipStoreButton.style.display = 'none'; statsContainer.style.display = 'none'; messageBox.style.display = 'block'; }
        function hideMessage() { messageBox.style.display = 'none'; }

        // --- Store Logic ---
        function updateStoreUI() {
            storeScoreDisplay.textContent = `Current Score: $${score}`;
            stockSatelliteDisplay.textContent = `Stock: ${storeStockSatellite}`;
            stockBaseDisplay.textContent = `Stock: ${storeStockBase}`;
            stockCityDisplay.textContent = `Stock: ${storeStockCity}`;
            stockShieldDisplay.textContent = `Stock: ${storeStockShield}`;
            stockSatShieldDisplay.textContent = `Stock: ${storeStockSatShield}`;
            stockSonicWaveDisplay.textContent = `Stock: ${storeStockSonicWave}`;
            stockBombDisplay.textContent = `Stock: ${storeStockBomb}`;

            const canAffordSatellite = score >= COST_SATELLITE;
            const satelliteInStock = storeStockSatellite > 0;
            const activeSatellites = satelliteBases.filter(s => s.alive).length;
            const canPlaceSatellite = activeSatellites < MAX_ACTIVE_SATELLITES;
            buySatelliteButton.disabled = !(canAffordSatellite && satelliteInStock && canPlaceSatellite);

            const canAffordBase = score >= COST_BASE;
            const baseInStock = storeStockBase > 0;
            const canRebuildBase = bases.some(b => !b.alive);
            buyBaseButton.disabled = !(canAffordBase && baseInStock && canRebuildBase);

            const canAffordCity = score >= COST_CITY;
            const cityInStock = storeStockCity > 0;
            const canRebuildCity = cities.some(c => !c.alive);
            buyCityButton.disabled = !(canAffordCity && cityInStock && canRebuildCity);

            const canAffordShield = score >= COST_SHIELD;
            const shieldInStock = storeStockShield > 0;
            const canPlaceShield = baseShields.some((shield, index) => bases[index].alive && (!shield || !shield.alive));
            buyShieldButton.disabled = !(canAffordShield && shieldInStock && canPlaceShield);

            const canAffordSatShield = score >= COST_SAT_SHIELD;
            const satShieldInStock = storeStockSatShield > 0;
            const canPlaceSatShield = satelliteBases.some(s => s.alive && (!s.shield || !s.shield.alive));
            buySatShieldButton.disabled = !(canAffordSatShield && satShieldInStock && canPlaceSatShield);

            const canAffordSonic = score >= COST_SONIC_WAVE;
            const sonicInStock = storeStockSonicWave > 0;
            buySonicWaveButton.disabled = !(canAffordSonic && sonicInStock);
            const canAffordSonic10 = score >= COST_SONIC_WAVE * 10;
            const sonicInStock10 = storeStockSonicWave >= 10;
            buySonicWave10Button.disabled = !(canAffordSonic10 && sonicInStock10);

            const canAffordBomb = score >= COST_BOMB;
            const bombInStock = storeStockBomb > 0;
            buyBombButton.disabled = !(canAffordBomb && bombInStock);
            const canAffordBomb10 = score >= COST_BOMB * 10;
            const bombInStock10 = storeStockBomb >= 10;
            buyBomb10Button.disabled = !(canAffordBomb10 && bombInStock10);

            const costFasterMissile = calculateUpgradeCost(COST_FASTER_MISSILE_BASE, playerMissileSpeedLevel);
            costFasterMissileDisplay.textContent = `Cost: $${costFasterMissile}`;
            levelFasterMissileDisplay.textContent = `Level: ${playerMissileSpeedLevel}/${MAX_UPGRADE_LEVEL}`;
            buyFasterMissileButton.disabled = !(score >= costFasterMissile && playerMissileSpeedLevel < MAX_UPGRADE_LEVEL);
            if (playerMissileSpeedLevel >= MAX_UPGRADE_LEVEL) { costFasterMissileDisplay.textContent = "MAX LEVEL"; buyFasterMissileButton.disabled = true; }

            const costWiderExplosion = calculateUpgradeCost(COST_WIDER_EXPLOSION_BASE, explosionRadiusLevel);
            costWiderExplosionDisplay.textContent = `Cost: $${costWiderExplosion}`;
            levelWiderExplosionDisplay.textContent = `Level: ${explosionRadiusLevel}/${MAX_UPGRADE_LEVEL}`;
            buyWiderExplosionButton.disabled = !(score >= costWiderExplosion && explosionRadiusLevel < MAX_UPGRADE_LEVEL);
            if (explosionRadiusLevel >= MAX_UPGRADE_LEVEL) { costWiderExplosionDisplay.textContent = "MAX LEVEL"; buyWiderExplosionButton.disabled = true; }
        }
        function findAndRebuildBase() { const deadBaseIndex = bases.findIndex(b => !b.alive); if (deadBaseIndex !== -1) { bases[deadBaseIndex].alive = true; bases[deadBaseIndex].ammo = selectedDifficultyAmmo; return true; } return false; }
        function findAndRebuildCity() { const deadCityIndex = cities.findIndex(c => !c.alive); if (deadCityIndex !== -1) { cities[deadCityIndex].alive = true; return true; } return false; }
        function buyReplacementBase() { if (score >= COST_BASE && storeStockBase > 0) { if (findAndRebuildBase()) { score -= COST_BASE; storeStockBase--; updateStoreUI(); updateUI(); } } }
        function buyReplacementCity() { if (score >= COST_CITY && storeStockCity > 0) { if (findAndRebuildCity()) { score -= COST_CITY; storeStockCity--; updateStoreUI(); updateUI(); } } }
        function buySatellite() { const activeSatellitesCount = satelliteBases.filter(s => s.alive).length; if (score >= COST_SATELLITE && storeStockSatellite > 0 && activeSatellitesCount < MAX_ACTIVE_SATELLITES) { let placed = false; const basePositionsRatios = [0.15, 0.5, 0.85]; for (let i = 0; i < 3; i++) { const targetX = basePositionsRatios[i] * canvas.width; const satelliteX = targetX - (canvas.width * SATELLITE_WIDTH_RATIO / 2); const positionOccupied = satelliteBases.some(s => s.alive && Math.abs(s.x - satelliteX) < 1); if (!positionOccupied) { score -= COST_SATELLITE; storeStockSatellite--; const newSatellite = createSatelliteBase(basePositionsRatios[i], SATELLITE_Y_POS_RATIO); satelliteBases.push(newSatellite); placed = true; break; } } if(placed) { updateStoreUI(); updateUI(); } } }
        function buyShield() { if (score >= COST_SHIELD && storeStockShield > 0) { let shieldPlaced = false; for (let i = 0; i < bases.length; i++) { if (bases[i].alive && (!baseShields[i] || !baseShields[i].alive)) { score -= COST_SHIELD; storeStockShield--; baseShields[i] = { alive: true, strength: SHIELD_STRENGTH_START, flashTimer: 0 }; shieldPlaced = true; break; } } if(shieldPlaced) { updateStoreUI(); updateUI(); } } }
        function buySatShield() { if (score >= COST_SAT_SHIELD && storeStockSatShield > 0) { let shieldPlaced = false; for (let i = 0; i < satelliteBases.length; i++) { const sat = satelliteBases[i]; if (sat.alive && (!sat.shield || !sat.shield.alive)) { score -= COST_SAT_SHIELD; storeStockSatShield--; sat.shield = { alive: true, strength: SHIELD_STRENGTH_START, flashTimer: 0 }; shieldPlaced = true; break; } } if(shieldPlaced) { updateStoreUI(); updateUI(); } } }
        function buySonicWave() { if (score >= COST_SONIC_WAVE && storeStockSonicWave > 0) { score -= COST_SONIC_WAVE; storeStockSonicWave--; inventorySonicWave++; updateStoreUI(); updateSpecialWeaponsUI(); } }
        function buyBomb() { if (score >= COST_BOMB && storeStockBomb > 0) { score -= COST_BOMB; storeStockBomb--; inventoryBomb++; updateStoreUI(); updateSpecialWeaponsUI(); } }
        function buyFasterMissile() { if (playerMissileSpeedLevel < MAX_UPGRADE_LEVEL) { const cost = calculateUpgradeCost(COST_FASTER_MISSILE_BASE, playerMissileSpeedLevel); if (score >= cost) { score -= cost; playerMissileSpeedLevel++; updateStoreUI(); } } }
        function buyWiderExplosion() { if (explosionRadiusLevel < MAX_UPGRADE_LEVEL) { const cost = calculateUpgradeCost(COST_WIDER_EXPLOSION_BASE, explosionRadiusLevel); if (score >= cost) { score -= cost; explosionRadiusLevel++; updateStoreUI(); } } }
        function buySonicWave10() {
            const cost10 = COST_SONIC_WAVE * 10;
            if (score >= cost10 && storeStockSonicWave >= 10) {
                score -= cost10;
                storeStockSonicWave -= 10;
                inventorySonicWave += 10;
                updateStoreUI();
                updateSpecialWeaponsUI();
            }
        }
        function buyBomb10() {
            const cost10 = COST_BOMB * 10;
            if (score >= cost10 && storeStockBomb >= 10) {
                score -= cost10;
                storeStockBomb -= 10;
                inventoryBomb += 10;
                updateStoreUI();
                updateSpecialWeaponsUI();
            }
        }

        // --- Special Weapon Logic ---
        function updateSpecialWeaponsUI() { sonicWaveCountDisplay.textContent = inventorySonicWave; bombCountDisplay.textContent = inventoryBomb; const canUseSpecials = gameHasStarted && !isGameOver && !isPaused && !transitioningWave; sonicWaveControl.classList.toggle('disabled', inventorySonicWave <= 0 || !canUseSpecials || activeSonicWave); bombControl.classList.toggle('disabled', inventoryBomb <= 0 || !canUseSpecials); bombControl.classList.toggle('armed', isBombArmed); if (canUseSpecials) { canvas.style.cursor = isBombArmed ? 'cell' : 'crosshair'; } else { canvas.style.cursor = 'default'; } }
        function triggerSonicWave() { if (inventorySonicWave > 0 && !activeSonicWave && !sonicWaveControl.classList.contains('disabled')) { inventorySonicWave--; activeSonicWave = { y: canvas.height - (canvas.height * GROUND_HEIGHT_RATIO), alive: true }; updateSpecialWeaponsUI(); } }
        function armBomb() { if (inventoryBomb > 0 && !bombControl.classList.contains('disabled')) { isBombArmed = !isBombArmed; updateSpecialWeaponsUI(); } }
        function deployBomb(clickX, clickY) {
            if (isBombArmed) {
                inventoryBomb--;
                isBombArmed = false;
                const bombRadius = getCurrentPlayerExplosionRadius() * BOMB_EXPLOSION_RADIUS_MULTIPLIER;
                const bombDuration = EXPLOSION_DURATION * BOMB_EXPLOSION_DURATION_MULTIPLIER;
                createExplosion(clickX, clickY, EXPLOSION_RADIUS_START, '#ffffff', bombRadius, bombDuration);
                updateSpecialWeaponsUI();
            }
        }

        // --- Drawing Functions ---
        function drawBackground() { ctx.fillStyle = '#00001a'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO); const numStars = Math.floor(canvas.width * canvas.height / 5000); for (let i = 0; i < numStars; i++) { let x = Math.random() * canvas.width; let y = Math.random() * groundY; let radius = Math.random() * 1.5; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill(); } ctx.fillStyle = '#3b2e1a'; ctx.fillRect(0, groundY, canvas.width, canvas.height * GROUND_HEIGHT_RATIO); }
        function drawGameObjects() { cities.forEach(city => city.draw()); bases.forEach(base => base.draw()); satelliteBases.forEach(sat => { sat.draw(); if (sat.shield && sat.shield.alive) { const shieldCenterX = sat.x + sat.width / 2; const shieldCenterY = sat.y + sat.height / 2; const shieldRadiusX = sat.width * 0.6 + 4; const shieldRadiusY = sat.height * 0.8 + 4; let shieldColor = SHIELD_COLOR_25; if (sat.shield.strength > 75) shieldColor = SHIELD_COLOR_FULL; else if (sat.shield.strength > 50) shieldColor = SHIELD_COLOR_75; else if (sat.shield.strength > 25) shieldColor = SHIELD_COLOR_50; if (sat.shield.flashTimer > 0) { shieldColor = SHIELD_FLASH_COLOR; sat.shield.flashTimer--; } ctx.beginPath(); ctx.ellipse(shieldCenterX, shieldCenterY, shieldRadiusX, shieldRadiusY, 0, 0, Math.PI * 2); ctx.strokeStyle = shieldColor; ctx.lineWidth = 2; ctx.stroke(); ctx.lineWidth = 1; } }); for (let i = 0; i < baseShields.length; i++) { const shield = baseShields[i]; if (shield && shield.alive) { const base = bases[i]; const shieldCenterX = base.x + base.width / 2; const shieldRadius = BASE_SHIELD_RADIUS_MULTIPLIER * ((base.width / 2) + (canvas.width * CITY_WIDTH_RATIO / 2) + 5); let shieldColor = SHIELD_COLOR_25; if (shield.strength > 75) shieldColor = SHIELD_COLOR_FULL; else if (shield.strength > 50) shieldColor = SHIELD_COLOR_75; else if (shield.strength > 25) shieldColor = SHIELD_COLOR_50; if (shield.flashTimer > 0) { shieldColor = SHIELD_FLASH_COLOR; shield.flashTimer--; } const startX = shieldCenterX - shieldRadius; const endX = shieldCenterX + shieldRadius; const shieldTopY = base.y - 15; const controlY = shieldTopY - shieldRadius * 0.3; ctx.beginPath(); ctx.moveTo(startX, shieldTopY); ctx.quadraticCurveTo(shieldCenterX, controlY, endX, shieldTopY); ctx.strokeStyle = shieldColor; ctx.lineWidth = 3; ctx.stroke(); ctx.lineWidth = 1; } } if (activeSonicWave && activeSonicWave.alive) { ctx.fillStyle = SONIC_WAVE_COLOR; ctx.fillRect(0, activeSonicWave.y - SONIC_WAVE_HEIGHT, canvas.width, SONIC_WAVE_HEIGHT); ctx.strokeStyle = 'rgba(255, 100, 255, 0.8)'; ctx.lineWidth = 1; const numLines = 5; for(let i=0; i < numLines; i++) { const lineY = activeSonicWave.y - (SONIC_WAVE_HEIGHT / numLines * (i + 0.5)); ctx.beginPath(); ctx.moveTo(0, lineY); ctx.lineTo(canvas.width, lineY); ctx.stroke(); } } incomingMissiles.forEach(missile => missile.draw()); playerMissiles.forEach(missile => missile.draw()); explosions.forEach(explosion => explosion.draw()); planes.forEach(plane => plane.draw()); planeBombs.forEach(bomb => bomb.draw()); }

        // --- Update Functions ---
        function updateGameObjects() {
            // Increment wave timer
            waveTimer++;

            spawnEnemiesForWave();
            if (activeSonicWave && activeSonicWave.alive) {
                 activeSonicWave.y -= SONIC_WAVE_SPEED;
                 const waveTop = activeSonicWave.y - SONIC_WAVE_HEIGHT;
                 const waveBottom = activeSonicWave.y;
                 incomingMissiles.forEach(missile => { if (missile.alive && missile.y >= waveTop && missile.y <= waveBottom) { missile.alive = false; statsEnemyMissilesDestroyed++; const finalPoints = Math.round(POINTS_PER_MISSILE * scoreMultiplier * difficultyScoreMultiplier); score += finalPoints; gameTotalScore += finalPoints; createExplosion(missile.x, missile.y, EXPLOSION_RADIUS_START, missile.color); } });
                 planeBombs.forEach(bomb => { if (bomb.alive && bomb.y >= waveTop && bomb.y <= waveBottom) { bomb.alive = false; statsPlaneBombsDestroyed++; const finalPoints = Math.round(PLANE_BOMB_POINTS * scoreMultiplier * difficultyScoreMultiplier); score += finalPoints; gameTotalScore += finalPoints; createExplosion(bomb.x, bomb.y, EXPLOSION_RADIUS_START * 0.8, bomb.color); } });
                 if (waveTop <= 0) { activeSonicWave.alive = false; activeSonicWave = null; updateSpecialWeaponsUI(); }
            }
            incomingMissiles.forEach(missile => missile.update());
            playerMissiles.forEach(missile => missile.update());
            explosions.forEach(explosion => explosion.update());
            planes.forEach(plane => plane.update());
            planeBombs.forEach(bomb => bomb.update());
            incomingMissiles = incomingMissiles.filter(missile => missile.alive);
            playerMissiles = playerMissiles.filter(missile => missile.alive);
            explosions = explosions.filter(explosion => explosion.alive);
            planes = planes.filter(plane => plane.alive);
            planeBombs = planeBombs.filter(bomb => bomb.alive);
            if (accuracyBonusMessageTimer > 0) {
                 accuracyBonusMessageTimer--;
                 if (accuracyBonusMessageTimer === 0) { messageBonusText.textContent = ""; }
            }
        }
        function updateUI() {
            scoreDisplay.textContent = `SCORE: $${score}`;
            highScoreDisplay.textContent = `HI: $${highScore}`;
            waveDisplay.textContent = `WAVE: ${currentWave + 1}`;
            const livingCities = cities.filter(c => c.alive).length;
            citiesLeftDisplay.textContent = `CITIES: ${livingCities}`;
            multiplierDisplay.textContent = `MULT: ${scoreMultiplier.toFixed(1)}x`;
            bonusIndicator.style.display = bonusMissileCount > 0 ? 'inline-block' : 'none';
            if (bonusMissileCount > 0) { bonusIndicator.textContent = `BONUS FIRE +${bonusMissileCount}!`; }
        }

        // --- Game Loop ---
        function gameLoop() {
            if (isPaused) { gameLoopId = null; return; }
            checkGameOverConditions();
            if (isGameOver && explosions.length === 0 && planeBombs.length === 0 && !activeSonicWave && !transitioningWave) {
                console.log("gameLoop: Stopping loop (Game Over condition met)");
                gameLoopId = null;
                return;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawGameObjects();
            if (!isGameOver && !transitioningWave) {
                updateGameObjects();
                updateUI();
                updateSpecialWeaponsUI();
                checkWaveEnd();
            } else if (isGameOver) {
                // Only update explosions and bombs if game is over but effects are still active
                explosions.forEach(explosion => explosion.update());
                planeBombs.forEach(bomb => bomb.update());
                 if (activeSonicWave && activeSonicWave.alive) {
                    activeSonicWave.y -= SONIC_WAVE_SPEED;
                     if (activeSonicWave.y - SONIC_WAVE_HEIGHT <= 0) { activeSonicWave.alive = false; activeSonicWave = null; }
                 }
                explosions = explosions.filter(explosion => explosion.alive);
                planeBombs = planeBombs.filter(bomb => bomb.alive);
            }
            // Request next frame if game isn't over OR if there are still active effects
            if (!isGameOver || explosions.length > 0 || planeBombs.length > 0 || activeSonicWave) {
                gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                console.log("gameLoop: Stopping loop (End condition met)");
                gameLoopId = null; // Ensure loop stops
            }
        }

        // --- NEW: Function to Fetch and Display Leaderboard ---
        async function fetchAndDisplayLeaderboard() {
            console.log("Fetching leaderboard...");
            leaderboardLoading.textContent = "Loading...";
            leaderboardList.innerHTML = ''; // Clear previous entries except loading
            leaderboardList.appendChild(leaderboardLoading);
            leaderboardContainer.style.display = 'block'; // Show container

            try {
                // Make sure to use the correct path to your function
                const response = await fetch('/scores'); // Uses the Functions route

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const scores = await response.json();
                console.log("Leaderboard data received:", scores);

                leaderboardLoading.style.display = 'none'; // Hide loading message

                if (scores && scores.length > 0) {
                    scores.forEach((entry, index) => {
                        const li = document.createElement('li');
                        const rankSpan = document.createElement('span');
                        rankSpan.className = 'rank';
                        rankSpan.textContent = `${index + 1}.`;

                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'name';
                        // Basic sanitization display-side (Function should sanitize on input)
                        nameSpan.textContent = entry.name.replace(/</g, "&lt;").replace(/>/g, "&gt;");

                        const scoreSpan = document.createElement('span');
                        scoreSpan.className = 'score';
                        scoreSpan.textContent = `$${entry.score}`;

                        li.appendChild(rankSpan);
                        li.appendChild(nameSpan);
                        li.appendChild(scoreSpan);
                        leaderboardList.appendChild(li);
                    });
                } else {
                    leaderboardLoading.textContent = "No scores yet!";
                    leaderboardLoading.style.display = 'block';
                }

            } catch (error) {
                console.error('Error fetching leaderboard:', error);
                leaderboardLoading.textContent = "Error loading scores.";
                leaderboardLoading.style.display = 'block';
            }
        }

        // --- NEW: Function to Submit Score ---
        async function submitHighScore() {
            const name = playerNameInput.value.trim().toUpperCase();
            // Use gameTotalScore for the final submission
            const finalScore = gameTotalScore; // Make sure gameTotalScore is correctly updated

            if (!name || name.length === 0 || name.length > 18) {
                submissionStatus.textContent = "Enter 1-18 characters."; // Error message
                submissionStatus.style.color = "#ff0000";
                return; // Stop the submission if invalid
            }
            if (finalScore <= 0) {
                 submissionStatus.textContent = "No score to submit.";
                 submissionStatus.style.color = "#ffff00";
                 submitScoreButton.disabled = true;
                 return;
            }

            console.log(`Submitting score: Name=${name}, Score=${finalScore}`);
            submitScoreButton.disabled = true;
            submissionStatus.textContent = "Submitting...";
            submissionStatus.style.color = "#00ff00";
            // Store name locally for pre-filling next time
            // localStorage.setItem('lastPlayerName', name); // Stop saving the name

            try {
                const response = await fetch('/scores', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ name: name, score: finalScore }),
                });

                if (!response.ok) {
                     const errorText = await response.text();
                     throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                console.log("Submission response:", result);
                submissionStatus.textContent = "Score Submitted!";
                submissionStatus.style.color = "#00ff00";
                // Optionally, refresh the leaderboard display after submission
                // fetchAndDisplayLeaderboard(); // Might be better to wait until restart

            } catch (error) {
                console.error('Error submitting score:', error);
                submissionStatus.textContent = "Submission Failed.";
                submissionStatus.style.color = "#ff0000";
                submitScoreButton.disabled = false; // Re-enable on failure
            }
        }

        // --- Event Listeners ---
        canvas.addEventListener('click', (event) => {
            if (isGameOver || isPaused || transitioningWave || !gameHasStarted) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (event.clientX - rect.left) * scaleX;
            const clickY = (event.clientY - rect.top) * scaleY;
            const groundY = canvas.height - (canvas.height * GROUND_HEIGHT_RATIO);
            if (clickY < 20 || clickY > groundY) return; // Ignore clicks too high or low
            if (isBombArmed) { deployBomb(clickX, clickY); return; } // Deploy bomb if armed

            // Find nearest base/satellite with ammo
            let nearestSource = null; let minDistance = Infinity;
            const potentialSources = [ ...bases.filter(b => b.alive && b.ammo > 0), ...satelliteBases.filter(s => s.alive && s.ammo > 0) ];
            potentialSources.forEach(source => {
                const sourceCenterX = source.x + source.width / 2;
                const sourceTopY = source.isSatellite ? source.y + source.height : source.y; // Use top of base, bottom of satellite for launch point
                const d = distance(clickX, clickY, sourceCenterX, sourceTopY);
                if (d < minDistance) { minDistance = d; nearestSource = source; }
            });

            // Fire missile(s) from the nearest source
            if (nearestSource) {
                const startX = nearestSource.x + nearestSource.width / 2;
                const startY = nearestSource.isSatellite ? nearestSource.y + nearestSource.height : nearestSource.y;
                const totalMissilesToFire = 1 + bonusMissileCount; // Base + bonus
                const actualMissilesToFire = Math.min(totalMissilesToFire, nearestSource.ammo); // Don't fire more than available

                if (actualMissilesToFire > 0) {
                    nearestSource.ammo -= actualMissilesToFire;
                    for (let i = 0; i < actualMissilesToFire; i++) {
                        // Apply spread if firing multiple bonus missiles
                        const currentOffset = (actualMissilesToFire > 1) ? (i - (actualMissilesToFire - 1) / 2) * BONUS_FIRE_SPREAD : 0;
                        playerMissiles.push(createPlayerMissile(startX + currentOffset, startY, clickX, clickY));
                    }
                    updateUI(); // Update ammo display on base
                }
            }
        });

        // --- MODIFIED: restartButton Event Listener (handles both restart buttons) ---
        document.querySelectorAll('#restartButton').forEach(button => {
            button.addEventListener('click', () => {
                if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
                isGameOver = true; gameHasStarted = false; isPaused = false; transitioningWave = false; difficultySelected = false;
                // Reset game state variables
                score = 0; gameTotalScore = 0; currentWave = -1; consecutiveIntercepts = 0; scoreMultiplier = 1.0;
                playerMissileSpeedLevel = 0; explosionRadiusLevel = 0; bonusMissileCount = 0;
                storeStockSatellite = MAX_STOCK_SATELLITE; storeStockBase = MAX_STOCK_BASE; storeStockCity = MAX_STOCK_CITY; storeStockShield = MAX_STOCK_SHIELD; storeStockSatShield = MAX_STOCK_SAT_SHIELD; storeStockSonicWave = MAX_STOCK_SONIC_WAVE; storeStockBomb = MAX_STOCK_BOMB;
                inventorySonicWave = 0; inventoryBomb = 0; isBombArmed = false; activeSonicWave = null;
                satelliteBases = []; baseShields = [null, null, null]; cities = []; bases = []; incomingMissiles = []; playerMissiles = []; explosions = []; planes = []; planeBombs = [];
                selectedDifficultyName = ''; difficultyScoreMultiplier = 1.0;
                statsMissilesFired = 0; statsEnemyMissilesDestroyed = 0; statsPlaneBombsDestroyed = 0; statsPlanesDestroyed = 0; statsCitiesLost = 0; statsBasesLost = 0; statsAccuracyBonusHits = 0;

                // Reset UI elements to initial state
                startMenuContainer.style.display = 'flex';
                canvasContainer.style.display = 'none'; canvas.style.display = 'none';
                uiContainer.style.display = 'none'; controlsContainer.style.display = 'none'; specialWeaponsUIDiv.style.display = 'none';
                pauseOverlay.style.display = 'none'; hideMessage(); storeModal.style.display = 'none';
                actualStartButton.style.display = 'none'; actualStartButton.disabled = true;
                // Hide all restart buttons initially
                document.querySelectorAll('#restartButton').forEach(btn => btn.style.display = 'none');
                pauseButton.style.display = 'none'; screenshotButton.style.display = 'none';
                bonusIndicator.style.display = 'none'; statsContainer.style.display = 'none';
                scoreSubmissionDiv.style.display = 'none'; // Hide submission form
                document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('selected'));

                // Update high score and fetch leaderboard for start menu
                highScore = parseInt(localStorage.getItem('missileCommandHighScore') || '0');
                startHighScoreDisplay.textContent = `High Score: $${highScore}`;
                fetchAndDisplayLeaderboard(); // Fetch leaderboard when returning to start menu
            });
        });

        pauseButton.addEventListener('click', togglePause);
        screenshotButton.addEventListener('click', saveScreenshot);
        storeContinueButton.addEventListener('click', proceedToNextWave);
        buyBaseButton.addEventListener('click', buyReplacementBase);
        buyCityButton.addEventListener('click', buyReplacementCity);
        buySatelliteButton.addEventListener('click', buySatellite);
        buyShieldButton.addEventListener('click', buyShield);
        buySatShieldButton.addEventListener('click', buySatShield);
        buySonicWaveButton.addEventListener('click', buySonicWave);
        buyBombButton.addEventListener('click', buyBomb);
        buyFasterMissileButton.addEventListener('click', buyFasterMissile);
        buyWiderExplosionButton.addEventListener('click', buyWiderExplosion);
        buySonicWave10Button.addEventListener('click', buySonicWave10);
        buyBomb10Button.addEventListener('click', buyBomb10);
        goToStoreButton.addEventListener('click', () => { hideMessage(); updateStoreUI(); storeModal.style.display = 'block'; });
        skipStoreButton.addEventListener('click', proceedToNextWave);
        document.querySelectorAll('.difficulty-button').forEach(button => {
            button.addEventListener('click', (event) => {
                try {
                    console.log("Difficulty button clicked:", event.target.textContent);
                    selectedDifficultyAmmo = parseInt(event.target.getAttribute('data-ammo'), 10);
                    difficultyScoreMultiplier = parseFloat(event.target.getAttribute('data-multiplier') || '1.0');
                    difficultySelected = true;
                    selectedDifficultyName = event.target.textContent;
                    console.log("Difficulty set:", selectedDifficultyName, "Ammo:", selectedDifficultyAmmo, "Multiplier:", difficultyScoreMultiplier);
                    document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('selected'));
                    event.target.classList.add('selected');
                    console.log("Selected class added.");
                    if (actualStartButton) {
                         console.log("Attempting to show/enable Start Game button...");
                         actualStartButton.style.display = 'inline-block';
                         actualStartButton.disabled = false;
                         console.log("Start Game button display:", actualStartButton.style.display, "disabled:", actualStartButton.disabled);
                    } else {
                         console.error("ERROR: actualStartButton element not found!");
                    }
                } catch (error) {
                     console.error("Error in difficulty button listener:", error);
                }
            });
        });
        actualStartButton.addEventListener('click', () => { if (difficultySelected) { startGame(); } });
        sonicWaveControl.addEventListener('click', () => { if (!sonicWaveControl.classList.contains('disabled')) { triggerSonicWave(); } });
        bombControl.addEventListener('click', () => { if (!bombControl.classList.contains('disabled')) { armBomb(); } });
        window.addEventListener('keydown', (event) => { if (event.code === 'Space' && !isGameOver && !transitioningWave && gameHasStarted && storeModal.style.display === 'none' && messageBox.style.display === 'none' ) { event.preventDefault(); togglePause(); } });

        // --- NEW: Event Listener for Score Submission ---
        submitScoreButton.addEventListener('click', submitHighScore);
        // Allow submitting with Enter key from input field
        playerNameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default form submission
                submitHighScore();
            }
        });

        // --- MODIFIED: window.onload ---
        window.onload = () => {
            // Set canvas dimensions
            canvas.width = INTERNAL_WIDTH; canvas.height = INTERNAL_HEIGHT;

            // Load high score
            highScore = parseInt(localStorage.getItem('missileCommandHighScore') || '0');
            startHighScoreDisplay.textContent = `High Score: $${highScore}`;
            highScoreDisplay.textContent = `HI: $${highScore}`; // Also update in-game UI

            // Set initial UI visibility
            startMenuContainer.style.display = 'flex';
            canvasContainer.style.display = 'none'; canvas.style.display = 'none';
            uiContainer.style.display = 'none'; controlsContainer.style.display = 'none'; specialWeaponsUIDiv.style.display = 'none';
            messageBox.style.display = 'none'; storeModal.style.display = 'none'; pauseOverlay.style.display = 'none';
            actualStartButton.style.display = 'none';
            // Ensure all restart buttons are hidden initially
            document.querySelectorAll('#restartButton').forEach(btn => btn.style.display = 'none');
            pauseButton.style.display = 'none'; screenshotButton.style.display = 'none';
            bonusIndicator.style.display = 'none'; statsContainer.style.display = 'none';
            scoreSubmissionDiv.style.display = 'none'; // Ensure submission form is hidden initially

            // Fetch leaderboard on load
            fetchAndDisplayLeaderboard();

            // Service worker registration (optional)
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js').then((registration) => {
                    console.log('[Service Worker] registered:', registration.scope);
                }).catch((error) => {
                    console.error('[Service Worker] registration failed:', error);
                });
            } else {
                console.log('[Service Worker] not supported.');
            }
        }; // End of window.onload

    </script>

</body>
</html>
